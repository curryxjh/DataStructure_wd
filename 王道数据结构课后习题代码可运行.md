---
数据结构课后习题代码 -by账号已注销
---

###### ~加油肝™~<br>数据结构<br>──<br><u>课后习题代码<br>(Part.II)</u><br><br><br>**账号已注销**<br>*COPYRIGHT © 2023-2023. nil_xjh.*

# 王道数据结构课后习题代码可运行

## 第二章

### 2.2.3

#### p01

```c++
/*
 * p01
 */
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
bool Del_Min(SqlList *s, int &val);

int main()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 5);
    Insert_Val(slist, 3, 20);
    Insert_Val(slist, 4, 1);
    Insert_Val(slist, 5, 9);
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    puts("");
    int val;
    bool flag = Del_Min(slist, val);
    if(flag)
    {
        cout << "最小值为：" << val << endl;
        cout << "删除后的顺序表为： ";
        for (int i = 0; i < slist->length; ++i)
            cout << slist->data[i] << " ";
    }
    else
        puts("删除失败");
    return 0;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

bool Del_Min(SqlList * s, int &val)
{
    if(!s->length)
        return false;

    int id = 0;
    val = s->data[id];
    for (int i = 1; i < s->length; ++ i)
        if(s->data[i] < val)
        {
            id = i;
            val = s->data[i];
        }
    s->data[id] = s->data[s->length - 1];
    -- s->length;
    return true;
}
```

#### p02

```c++
/*
 * p02
 */
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
bool reverse_list(SqlList *s);

int main()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 5);
    Insert_Val(slist, 3, 20);
    Insert_Val(slist, 4, 1);
    Insert_Val(slist, 5, 9);
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    puts("");
    reverse_list(slist);
    cout << "逆置后的顺序表为：";
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    return 0;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

bool reverse_list(SqlList *s)
{
    for (int i = 0; i < s->length / 2; ++ i)
    {
        int tmp = s->data[i];
        s->data[i] = s->data[s->length - i - 1];
        s->data[s->length - i - 1] = tmp;
    }
}
```

#### p03

```c++
/*
 * p02
 * 双指针法也可，但会改变元素的相对位置,后期补一下
 */
// todo 双指针解法
#include <iostream>
#include <algorithm>
#include <cstdlib>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
void del_val_x_v1(SqlList *s, int x);
void del_val_x_v2(SqlList *s, int x);

int main()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 5);
    Insert_Val(slist, 3, 20);
    Insert_Val(slist, 4, 1);
    Insert_Val(slist, 5, 9);
    Insert_Val(slist, 2, 9);
    Insert_Val(slist, 2, 9);
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    cout << endl << "输入需要删除元素：";
    int x;
    cin >> x;
    del_val_x_v1(slist, x);
    cout << "删除元素后的顺序表为：";
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    cout << endl << "输入需要删除的第二个元素：";
    int y;
    cin >> y;
    del_val_x_v2(slist, y);
    cout << "删除元素后的顺序表为：";
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    return 0;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

void del_val_x_v1(SqlList *s, int x)
{
    int num = 0;
    for (int i = 0; i < s->length; ++ i)
        if (s->data[i] != x)
        {
            s->data[num] = s->data[i];
            ++ num;
        }
    s->length = num;
}

void del_val_x_v2(SqlList *s, int x)
{
    int num = 0;
    for (int i = 0; i < s->length; ++ i)
    {
        if (s->data[i] == x)
            ++ num;
        else
            s->data[i - num] = s->data[i];
    }
    s->length -= num;
}
```

#### p04

```c++
/*
 * p04
 */
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
bool Del_val(SqlList *s, int l, int r);

int main()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 5);
    Insert_Val(slist, 3, 6);
    Insert_Val(slist, 4, 7);
    Insert_Val(slist, 5, 8);
    Insert_Val(slist, 6, 9);
    Insert_Val(slist, 7, 10);
    Insert_Val(slist, 8, 11);
    Insert_Val(slist, 9, 12);
    Insert_Val(slist, 10, 13);
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    puts("");
    int l, r;
    cout << "请输入需要删除元素的区间范围：";
    cin >> l >> r;
    bool t = Del_val(slist, l, r);
    if(!t)
    {
        cout << "顺序表为空或输入不合法" << endl;
        return 0;
    }
    cout << "删除后的顺序表为：";
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    return 0;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

bool Del_val(SqlList *s, int l, int r)
{
    if ((l > r) || !s->length)
        return false;
    int head_max = 0, head_less = 0;
    for (head_max; s->data[head_max] < l; ++ head_max);
    if (head_max > s->length)
        return false;
    for (head_less = head_max; head_less < s->length && s->data[head_less] <= r; ++ head_less);
    for (; head_less < s->length; ++ head_less)
        s->data[head_max++] = s->data[head_less];
    s->length = head_max;
    return true;
}
```

#### p05

```c++
/*
 * p05
 */
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
bool Del_val(SqlList *s, int l, int r);

int main()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 5);
    Insert_Val(slist, 3, 20);
    Insert_Val(slist, 4, 7);
    Insert_Val(slist, 5, 13);
    Insert_Val(slist, 6, 9);
    Insert_Val(slist, 7, 2);
    Insert_Val(slist, 8, 11);
    Insert_Val(slist, 9, 31);
    Insert_Val(slist, 10, 13);
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    puts("");
    int l, r;
    cout << "请输入需要删除元素的区间范围：";
    cin >> l >> r;
    bool t = Del_val(slist, l, r);
    if(!t)
    {
        cout << "顺序表为空或输入不合法" << endl;
        return 0;
    }
    cout << "删除后的顺序表为：";
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    return 0;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

bool Del_val(SqlList *s, int l, int r)
{
    if ((l > r) || !s->length)
        return false;
    int k = 0;
    for (int i = 0; i < s->length; ++ i)
    {
        if (s->data[i] < l || s->data[i] > r)
        {
            s->data[k] = s->data[i];
            ++ k;
        }
    }
    s->length = k;
    return true;
}

```



#### p06

```c++
/*
 * p06
 */
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
bool Del_val(SqlList *s);

int main()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 4);
    Insert_Val(slist, 3, 5);
    Insert_Val(slist, 4, 5);
    Insert_Val(slist, 5, 5);
    Insert_Val(slist, 6, 7);
    Insert_Val(slist, 7, 12);
    Insert_Val(slist, 8, 12);
    Insert_Val(slist, 9, 31);
    Insert_Val(slist, 10, 54);
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    puts("");

    bool t = Del_val(slist);
    if (!t)
    {
        cout << "顺序表为空，不需要进行删除" << endl;
        return 0;
    }
    cout << "删除后的顺序表为：";
    for (int i = 0; i < slist->length; ++ i)
        cout << slist->data[i] << " ";
    return 0;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

bool Del_val(SqlList *s)
{
    if (!s->length)
        return false;
    int i, j;
    for (i = 0, j = 1; j < s->length; ++ j)
    {
        if (s->data[i] != s->data[j])
            s->data[++ i] = s->data[j];
    }
    s->length = i + 1;
    return true;
}
```

#### p07

```c++
/*
 * p07
 */
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef int ElemType;
const int MaxSize = 110;
struct SqlList
{
    ElemType data[MaxSize];
    int length;
};
bool Insert_Val(SqlList *s, int i, int val);
SqlList* Create_list_1();
SqlList* Create_list_2();
bool merge_list(SqlList *s, SqlList *t, SqlList *c);

int main()
{
    SqlList *l1 = Create_list_1();
    SqlList *l2 = Create_list_2();
    cout << "两个有序表为：" << endl;
    for (int i = 0; i < l1->length; ++ i)
        cout << l1->data[i] << " ";
    puts("");
    for (int i = 0; i < l2->length; ++ i)
        cout << l2->data[i] << " ";
    puts("");
    cout << "合并后的有序表为：" << endl;
    SqlList *ans = new SqlList;
    bool t = merge_list(l1, l2, ans);
    if (!t)
    {
        cout << "有误" << endl;
        return 0;
    }
    for (int i = 0; i < ans->length; ++ i)
        cout << ans->data[i] << " ";

    return 0;
}

SqlList* Create_list_1()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 4);
    Insert_Val(slist, 2, 4);
    Insert_Val(slist, 3, 5);
    Insert_Val(slist, 4, 5);
    Insert_Val(slist, 5, 5);
    Insert_Val(slist, 6, 7);
    Insert_Val(slist, 7, 12);
    Insert_Val(slist, 8, 12);
    return slist;
}

SqlList* Create_list_2()
{
    SqlList * slist = new SqlList;
    Insert_Val(slist, 1, 1);
    Insert_Val(slist, 2, 2);
    Insert_Val(slist, 3, 3);
    Insert_Val(slist, 4, 5);
    Insert_Val(slist, 5, 9);
    Insert_Val(slist, 6, 11);
    Insert_Val(slist, 7, 17);
    Insert_Val(slist, 8, 23);
    Insert_Val(slist, 9, 31);
    Insert_Val(slist, 10, 99);
    return slist;
}

bool Insert_Val(SqlList *s, int i, int val)
{
    if (i < 1 || i > s->length + 1)
        return false;
    if (s->length >= MaxSize)
        return false;
    for (int j = s->length; j >= i; -- j)
        s->data[j] = s->data[j - 1];
    s->data[i - 1] = val;
    ++ s->length;
    return true;
}

bool merge_list(SqlList *s, SqlList * t, SqlList *c)
{
    if (s->length + t->length > MaxSize)
        return false;
    int i = 0, j = 0, k = 0;
    while (i < s->length && j < t->length)
    {
        if (s->data[i] < t->data[j])
            c->data[k ++] = s->data[i ++];
        else
            c->data[k ++] = t->data[j ++];
    }
    cout << "here" << endl;
    while (i < s->length)
        c->data[k ++] = s->data[i ++];
    while (j < t->length)
        c->data[k ++] = t->data[j ++];
    c->length = k;
    return true;
}
```

#### p08

```c++
/*
 * p08
 */
#include <iostream>
using namespace std;
const int N = 110;
struct Sqlist
{
    int data[N];
    int length;
};
void Print(Sqlist *q);
Sqlist* Init_sqlist(int a[], int l);
void Reverse_list(Sqlist *q, int l, int r);

int main()
{
    int a[] = {2, 9, 12, 3, 4,8, 23, 1, 34, 11, 7, 3, 5, 19};
    int m = 6, n = 8;
    Sqlist* sqlist = Init_sqlist(a, sizeof (a) / 4);
    cout << "原顺序表为：";
    Print(sqlist);
    Reverse_list(sqlist, 0, m + n - 1);
    Print(sqlist);
    Reverse_list(sqlist, 0, n - 1);
    Print(sqlist);
    Reverse_list(sqlist, n, m + n - 1);
    cout << "转换后的顺序表为：";
    Print(sqlist);
    return 0;
}

void Print(Sqlist *q)
{
    for (int i = 0; i < q->length; ++ i)
        cout << q->data[i] << " ";
    cout << endl;
}


Sqlist* Init_sqlist(int a[], int l)
{
    Sqlist* sqlist = new Sqlist;
    for (int i = 0; i < l; ++ i)
        sqlist->data[i] = a[i];
    sqlist->length = l;
    return sqlist;
}

void Reverse_list(Sqlist *q, int l, int r)
{
    for (int i = l; i <= (l + r) / 2; ++ i)
    {
        int tmp = q->data[i];
        q->data[i] = q->data[l + r - i];
        q->data[l + r - i] = tmp;
    }
}
```

#### p09

```c++
/*
 * p09
 */

#include <iostream>
using namespace std;
const int N = 110;
struct Sqlist
{
    int data[N];
    int length;
};
void Print(Sqlist *q);
Sqlist* Init_sqlist(int a[], int l);
void Find_val(Sqlist *q, int val);

int main()
{
    int a[] = {2, 3, 5, 6, 7,8, 10, 11, 14, 15, 17, 23, 25, 29};
    int len = sizeof a / 4;
    Sqlist* sqlist = Init_sqlist(a, len);
    Print(sqlist);
    puts("");
    int x;
    cout << "请输入需要查找的值: ";
    cin >> x;
    Find_val(sqlist, x);
    Print(sqlist);
    return 0;
}


Sqlist* Init_sqlist(int a[], int l)
{
    Sqlist* sqlist = new Sqlist;
    for (int i = 0; i < l; ++ i)
        sqlist->data[i] = a[i];
    sqlist->length = l;
    return sqlist;
}

void Find_val(Sqlist *q, int val)
{
    int l = 0, r = q->length - 1;
    while (l < r)
    {
        int mid = (l + r) >> 1;
        if (q->data[mid] >= val)
            r = mid;
        else
            l = mid + 1;
    }
    if (q->data[l] == val && l != q->length - 1)
    {
        cout << "查找的元素在顺序表中" << endl;
        int tmp = q->data[l];
        q->data[l] = q->data[l + 1];
        q->data[l + 1] = tmp;
    }
    else
    {
        cout << "查找的元素不在顺序表中" << endl;
        for (int i = q->length - 1; i >= l; -- i)
            q->data[i + 1] = q->data[i];
        q->data[l] = val;
    }
}

void Print(Sqlist *q)
{
    for (int i = 0; i < q->length; ++ i)
        cout << q->data[i] << " ";
    cout << endl;
}
```

#### p10

```c++
/*
 * p10
 * (1) 算法基本思想:参照p08的思路,把数组堪称两部分ab，a即为需要左移的部分，b为不需要左移的部分，
 * 原顺序为ab，现在左移后需要得到顺序为ba，那么只要调换这两段字符的位置即可，但需要注意ab的长度不相同，
 * 所以不可以直接以中间位置为抽对换，参照线性代数的类似点(a逆b逆)逆=ba
 *
 * (2) 源码如下
 * (3) 时间复杂度： 空间复杂度：
 */

#include <iostream>
using namespace std;
const int N = 110;
struct Sqlist
{
    int data[N];
    int length;
};
void Print(Sqlist *q);
Sqlist* Init_sqlist(int a[], int l);
void exchange(Sqlist *q, int l, int r);
void remove_left(Sqlist *q, int pos);

int main()
{
    int a[] = {2, 3, 5, 6, 7,8, 10, 11, 14, 15, 17, 23, 25, 29};
    int len = sizeof a / 4;
    Sqlist* sqlist = Init_sqlist(a, len);
    Print(sqlist);
    puts("");
    int x;
    cout << "请输入需要左移动的位数: ";
    cin >> x;
    remove_left(sqlist, x);
    Print(sqlist);
    return 0;
}


Sqlist* Init_sqlist(int a[], int l)
{
    Sqlist* sqlist = new Sqlist;
    for (int i = 0; i < l; ++ i)
        sqlist->data[i] = a[i];
    sqlist->length = l;
    return sqlist;
}

void exchange(Sqlist *q, int l, int r)
{
    for (int i = l; i <= (l + r) / 2; ++ i)
    {
        int tmp = q->data[i];
        q->data[i] = q->data[l + r - i];
        q->data[l + r - i] = tmp;
    }
}

void remove_left(Sqlist *q, int pos)
{
    exchange(q, 0, pos - 1);
    exchange(q, pos, q->length - 1);
    exchange(q, 0, q->length - 1);
}

void Print(Sqlist *q)
{
    for (int i = 0; i < q->length; ++ i)
        cout << q->data[i] << " ";
    cout << endl;
}
```

#### p11

```c++
/*
 * p11
 * (1)算法基本思想：第一个想法将两个序列直接合并成一个有序序列，然后直接取中位数，
 * 此处不需要真的合并，两个指针不断去比较，然后判断已经得出有序序列的个数和两个序列长度和的/2上取整即可。
 * 这样做时间复杂度为O(n)，空间复杂度为O(1)
 * 第二个想法(王道正解)，去比较两个序列的中位数，若相等，则合并之后的序列中位数也为这个数字
 * 若不想等(a为第一个序列的中位数，b为第二个序列的中位数)
 * a>b：那么在a右边的一部分数字以及在b左边的一部分数字是无效的
 * a<b：那么在a左边一部分数字以及b右边一部分数字是无效的
 * (2)源代码如下
 * (3)时间复杂度：O(n) 空间复杂度：O(1)
 */
#include <iostream>
using namespace std;
const int N = 110;
struct Sqlist
{
    int data[N];
    int length;
};
void Print(Sqlist *q);
Sqlist* Init_sqlist(int a[], int l);
int find_middle(Sqlist *p, Sqlist *q);

int main()
{
    int a[] = {2, 3, 9, 11, 17,18, 20};
    int b[] = {3, 3, 5, 8, 9, 14, 19};
    int len1 = sizeof a / 4;
    int len2 = sizeof b / 4;
    Sqlist* sqlistA = Init_sqlist(a, len1);
    Sqlist* sqlistB = Init_sqlist(b,len2);
    Print(sqlistA);
    Print(sqlistB);
    puts("");
    int middle = find_middle(sqlistA, sqlistB);
    cout << middle << endl;
    return 0;
}


Sqlist* Init_sqlist(int a[], int l)
{
    Sqlist* sqlist = new Sqlist;
    for (int i = 0; i < l; ++ i)
        sqlist->data[i] = a[i];
    sqlist->length = l;
    return sqlist;
}

int find_middle(Sqlist *p, Sqlist *q)
{
    int i = 0, j = 0;
    int pos = (p->length + q->length - 1) / 2;
    int middle = 0;
    while (i < p->length && j < q->length)
    {
        if(p->data[i] <= q->data[j])
        {
            ++ middle;
            if (middle == pos + 1)
                return p->data[i];
            ++ i;
        }
        else
        {
            ++ middle;
            if (middle == pos + 1)
                return q->data[j];
            ++ j;
        }
    }
}

void Print(Sqlist *q)
{
    for (int i = 0; i < q->length; ++ i)
        cout << q->data[i] << " ";
    cout << endl;
}
```

#### p12

```c++
/*
 * p12
 * 算法基本思想：这道题题目简化的意思就是有一半的数是相等的，则这个数就是该序列的主元，否则就没有主元
 * 第一个想法：统计序列中所有元素的出现此处，找到出现次数最大的
 * 第二个想法：选取第一个元素为候选主元，然后遍历整个序列，当遇上该候选元素时+1，不是该元素-1
 * 若变成0了则更换候选主元。
 * 源代码如下：
 * 时间复杂度：O(n) 空间复杂度：O(1)
 */
#include <iostream>
using namespace std;
const int N = 110;
int A[] = {0, 5, 5, 3, 5, 7, 5, 5};
int find_main(int a[], int n);

int main()
{
    int n = sizeof A / 4;
    int x = find_main(A, n);
    if (x == -1)
        cout << "不存在主元" << endl;
    else
        cout << "主元为：" << x << endl;
    return 0;
}

int find_main(int a[], int n)
{
    int v = a[0], cnt = 1;
    for (int i = 1; i < n; ++ i)
    {
        if (a[i] == v)
            ++ cnt;
        else
        {
            -- cnt;
            if (!cnt)
            {
                v = a[i];
                cnt = 1;
            }
        }
        int count = 0;
        if (cnt)
        {
            for (int i = 0; i < n; ++ i)
                if(a[i] == v)
                    ++ count;
        }
        if (count > n/2)
            return v;
        else
            return -1;
    }
}
```

#### p13

```c++
/*
 * p13
 * (1) 新开一个数组用来存储原数组中出现的正整数，然后扫描一下新开的数组，第一个为0的就是最小正整数
 * (2) 源代码如下
 * (3) 时间复杂度：O(n) 空间复杂度：O(n)
 */
#include <iostream>
#include <cstring>
using namespace std;
const int N = 110;
int A[] = {1, 2, 3, 4, 5, 7, 5, 5};
int find_min_num(int a[], int n);

int main()
{
    int n = sizeof A / 4;
    cout << find_min_num(A, n) << endl;

    return 0;
}

int find_min_num(int a[], int n)
{
    int *b = new int[N];
    memset(b, 0, sizeof b * n);
    for (int i = 0; i < n; ++ i)
        if (a[i] > 0 && a[i] <= n)
            ++b[a[i]];
    for (int i = 1; i < n; ++ i)
        if (!b[i])
            return i;
}
```

#### p14

```c++
/*
 * p14
 * (1) 题目简化一下的意思就是从三个序列里，各选出来一个组成三元组，所有三元组里距离最小为多少。
 * (2) 源码如下
 * (3) 时间复杂度：O(n)  空间复杂度：O(1)
 */

#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
const int N = 110, INF = 0x3f3f3f3f;
int A[] = {-1, 0, 9};
int B[] = {-25, -10, 10, 11};
int C[] = {2, 9, 17, 30, 41};
int dist(int a[], int b[], int c[], int l1, int l2, int l3);

int main()
{
    cout << dist(A, B, C, sizeof A / 4, sizeof B / 4, sizeof C / 4) << endl;
    return 0;
}

int dist(int a[], int b[], int c[], int l1, int l2, int l3)
{
    int min_v = INF;
    for (int i = 0, j = 0, k = 0; i< l1 && j < l3 && k < l3;)
    {
        int d = abs(a[i] - b[j]) + abs(a[i] - c[k]) + abs(b[j] - c[k]);
        if (d < min_v)
            min_v = d;
        if (min(a[i], min(b[j], c[k])) == a[i])
            ++ i;
        else if (min(b[j], min(a[i], c[k])) == b[j])
            ++ j;
        else if (min(c[k], min(a[i], b[j])) == c[k])
            ++ k;
    }
    return min_v;
}
```

### 2.3.7

#### p01

```c++
/*
 * p01
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct SingleList
{
    Node* first;
    int length;
};
bool Init(SingleList* L); // 初始化单链表
bool Insert(SingleList* L, int i, int x); // 在ai之后插入一个新元素
bool Delete(SingleList* L, Node* node);
bool Print(SingleList* L); // 输出
bool Destory(SingleList* L); // 销毁单链表
void Dele_val_x(SingleList* L, Node* LN, int x);

int main()
{
    SingleList* singleList = new SingleList;
    Init(singleList);
    Insert(singleList, -1, 5);
    Insert(singleList, -1, 2);
    Insert(singleList, -1, 27);
    Insert(singleList, -1, 3);
    Insert(singleList, -1, 5);
    Insert(singleList, -1, 4);
    Insert(singleList, -1, 5);
    Insert(singleList, -1, 1);
    Insert(singleList, -1, 5);
    Print(singleList);
    Dele_val_x(singleList, singleList->first, 5);
    Print(singleList);
    Destory(singleList);
    return 0;
}

void Dele_val_x(SingleList* L, Node* LN, int x)
{
    Node* p;
    if (! LN)
        return;
    if (LN->element == x)
    {
        p = LN;
        LN = LN->link;
        Delete(L, p);
        Dele_val_x(L, LN, x);
    }
    else
        Dele_val_x(L, LN->link, x);
}

bool Init(SingleList* L)
{
    L->first = NULL;
    L->length = 0;
    return true;
}

bool Insert(SingleList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->first;
    for (int j = 0; j < i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    if (i > -1)
    {
        q->link = p->link;
        p->link = q;
    }
    else
    {
        q->link = L->first;
        L->first = q;
    }
    ++ L->length;
    return true;
}

bool Delete(SingleList* L, Node* node)
{
    Node* p = L->first;
    bool flag = false;
    Node* tmp;
    if (p == node)
    {
        tmp = L->first;
        L->first = p->link;
        flag = true;
    }
    else
    {
        while (p->link != node)
            p = p->link;
        if (p) {
            tmp = p->link;
            p->link = tmp->link;
            flag = true;
        }
    }
    free(tmp);
    return flag;
}

bool Print(SingleList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->first;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(SingleList* L)
{
    Node* p;
    while (L->first)
    {
        p = L->first->link;
        free(L->first);
        L->first = p;
    }
}
```

#### p02

```c+++
/*
 * p02
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Delete(HeaderList* L, Node* node); // 删除对应指针指向的节点
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
void Dele_val_x(HeaderList* L, Node* LN, int x);

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Insert(headerList, -1, 4);
    Print(headerList);
    Dele_val_x(headerList, headerList->head->link, 4);
    Print(headerList);
    return 0;
}

void Dele_val_x(HeaderList* L, Node* LN, int x)
{
    Node* p;
    if (! LN)
        return;
    if (LN->element == x)
    {
        p = LN;
        LN = LN->link;
        Delete(L, p);
        Dele_val_x(L, LN, x);
    }
    else
        Dele_val_x(L, LN->link, x);
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Delete(HeaderList* L, Node* node)
{
    Node* p = L->head;
    bool flag = false;
    Node* tmp;
    while (p->link != node)
        p = p->link;
    if (p)
    {
        tmp = p->link;
        p->link = tmp->link;
        flag = true;
    }
    free(tmp);
    return flag;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p03

```c++
/*
 * p03
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
void Print_Verse(HeaderList* L);

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Print(headerList);
    Print_Verse(headerList);

    return 0;
}

void Print_Verse(HeaderList* L)
{
    int *a = new int[L->length + 1];
    int idx = 0;
    Node* p = L->head->link;
    while (p)
    {
        a[idx ++] = p->element;
        p = p->link;
    }
    for (int i = idx - 1; ~i; --i)
        cout << a[i] << " ";
    puts("");
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p04

```c++
/*
 * p04
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
bool Delete_min(HeaderList* L);

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 1);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Print(headerList);
    Delete_min(headerList);
    Print(headerList);
    return 0;
}

bool Delete_min(HeaderList* L)
{
    Node* minvalpre, *minval;
    Node* pre = L->head, *p = pre->link;
    while (p)
    {
        if (p->element < minval->element)
        {
            minval = p;
            minvalpre = pre;
        }
        pre = p;
        p = p->link;
    }
    minvalpre->link = minval->link;
    free(minval);
    return true;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p05

```c++
/*
 * p05
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
bool reverse_list(HeaderList* L);

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 1);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Print(headerList);
    reverse_list(headerList);
    Print(headerList);
    return 0;
}

bool reverse_list(HeaderList* L)
{
    Node* p = L->head;
    Node* q = p->link;
    p->link = NULL;
    while (q)
    {
        Node* ne = q->link;
        q->link = p->link;
        p->link = q;
        q = ne;
    }
    return true;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p06

```c++
/*
 * p06
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
bool Sort_list(HeaderList* L);

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 1);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Print(headerList);
    Sort_list(headerList);
    Print(headerList);
    return 0;
}

bool Sort_list(HeaderList* L)
{
    if (! L->length)
        return false;
    Node* q = L->head->link;
    L->head->link = NULL;
    Node* p, *move;
    while (q != NULL)
    {
        p = q->link;
        move = L->head;
        while (move->link != NULL && move->link->element < q->element)
            move = move->link;
        q->link = move->link;
        move->link = q;
        q = p;
    }
    return true;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p07

```c++
/*
 * p07
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
bool Delete_val(HeaderList* L, int l, int r);

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 1);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Print(headerList);
    int l, r;
    cout << "删除元素区间范围: ";
    cin >> l >> r;
    Delete_val(headerList, l, r);
    Print(headerList);
    return 0;
}

bool Delete_val(HeaderList* L, int l, int r)
{
    if (! L->length)
        return false;
    Node* p = L->head->link;
    Node* q = L->head;
    while (p)
    {
        if (p->element >= l && p->element <= r)
        {
            Node* tmp = p;
            q->link = p->link;
            p = q->link;
            free(tmp);
        }
        else
        {
            q = p;
            p = p->link;
        }
    }
    return true;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p08

```c++
/*
 * p08
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
Node* Common_node(HeaderList* L1, HeaderList* L2);
int a[] = {3, 4, 1, 6, 7, 8};
int b[] = {9, 1, 6, 7, 8};

int main()
{
    HeaderList* L1 = buildList(a, sizeof a / 4);
    HeaderList* L2 = buildList(b, sizeof b / 4);
    Print(L1);
    Print(L2);
    Node* node = Common_node(L1, L2);
    if (node)
        while (node)
        {
            cout << node->element << " ";
            node = node->link;
        }
    else
        puts("无公共节点");
    return 0;
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

Node* Common_node(HeaderList* L1, HeaderList* L2) {
    int dist = 0;
    int l1 = L1->length, l2 = L2->length;
    Node *longlist, *shortlist;
    if (l1 > l2) {
        longlist = L1->head->link;
        shortlist = L2->head->link;
        dist = l1 - l2;
    } else {
        longlist = L2->head->link;
        shortlist = L1->head->link;
        dist = l2 - l1;
    }
    while (dist--)
        longlist = longlist->link;
    while (longlist)
    {
        if (longlist->element == shortlist->element && longlist->link->element == shortlist->link->element)
            return longlist;
        else
        {
            longlist = longlist->link;
            shortlist = shortlist->link;
        }
    }
    return NULL;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p09

```c++
/*
 * p09
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
void Sort_Print(HeaderList* L);
bool Print(HeaderList* L); // 输出

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 27);
    Insert(headerList, -1, 1);
    Insert(headerList, -1, 3);
    Insert(headerList, -1, 4);
    Insert(headerList, -1, 5);
    Print(headerList);
    Sort_Print(headerList);
    return 0;
}


bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

void Sort_Print(HeaderList* L)
{
    while (L->head->link)
    {
        Node *p = L->head->link;
        Node *pre = L->head;
        Node *del;
        int idx = 1;
        while (p->link)
        {
            if (pre->link->element > p->link->element)
                pre = p;
            p = p->link;
        }
        cout << pre->link->element << " ";
        del = pre->link;
        pre->link = del->link;
        free(del);
    }
    free(L->head);
}


bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}
```

#### p10

```c++
/*
 * p10
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
void disCreate(HeaderList* L, HeaderList*& L1, HeaderList*& L2);
int a[] = {3, 4, 1, 6, 7, 8};

int main()
{
    HeaderList* L = buildList(a, sizeof a / 4);
    Print(L);
    HeaderList* l1, * l2;
    disCreate(L, l1, l2);
    Print(l1);
    Print(l2);
    return 0;
}

void disCreate(HeaderList* L, HeaderList*& L1, HeaderList*& L2)
{
    L1 = new HeaderList;
    Init(L1);
    L2 = new HeaderList;
    Init(L2);
    Node* r1 = L1->head;
    Node* r2 = L2->head;
    int idx = 1;
    Node *p = L->head->link;
    while(p)
    {
        Node* tmp = p;
        p = p->link;
        tmp->link = NULL;
        if (idx % 2)
        {
            r1->link = tmp;
            r1 = tmp;
        }
        else
        {
            r2->link = tmp;
            r2 = tmp;
        }
        ++ idx;
    }
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p11

```c++
/*
 * p11
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
void disCreate(HeaderList* L, HeaderList*& L1, HeaderList*& L2);
int a[] = {3, 4, 1, 6, 7, 8};

int main()
{
    HeaderList* L = buildList(a, sizeof a / 4);
    Print(L);
    HeaderList* l1, * l2;
    disCreate(L, l1, l2);
    Print(l1);
    Print(l2);
    return 0;
}

void disCreate(HeaderList* L, HeaderList*& L1, HeaderList*& L2)
{
    L1 = new HeaderList;
    Init(L1);
    L2 = new HeaderList;
    Init(L2);
    Node* r1 = L1->head;
    int idx = 1;
    Node *p = L->head->link;
    while(p)
    {
        Node* tmp = p;
        p = p->link;
        tmp->link = NULL;
        if (idx % 2)
        {
            r1->link = tmp;
            r1 = tmp;
        }
        else
        {
            tmp->link = L2->head->link;
            L2->head->link = tmp;
        }
        ++ idx;
    }
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p12

```c++
/*
 * p12
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
bool Insert(HeaderList* L, int i, int x); // 在ai之后插入一个新元素
bool Del_same_val(HeaderList* L);
bool Print(HeaderList* L); // 输出

int main()
{
    HeaderList* headerList = new HeaderList;
    Init(headerList);
    Insert(headerList, -1, 9);
    Insert(headerList, -1, 9);
    Insert(headerList, -1, 7);
    Insert(headerList, -1, 6);
    Insert(headerList, -1, 5);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 2);
    Insert(headerList, -1, 2);
    Print(headerList);
    Del_same_val(headerList);
    Print(headerList);
    return 0;
}


bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Insert(HeaderList* L, int i, int x)
{
    if (i < -1 || i > L->length - 1)
        return false;
    Node* p = L->head;
    for (int j = 0; j <= i; ++ j)
        p = p->link;
    Node* q = new Node;
    q->element = x;
    q->link = p->link;
    p->link = q;
    ++ L->length;
    return true;
}

bool Del_same_val(HeaderList* L)
{
    if (! L->length)
        return false;
    Node* p = L->head->link;
    while (p->link)
    {
        if (p->element == p->link->element)
        {
            Node* tmp = p->link;
            p->link = tmp->link;
            free(tmp);
        }
        else
            p = p->link;
    }
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}
```

#### p13

```c++
/*
 * p13
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
HeaderList* Merge_Decline(HeaderList*& L1, HeaderList*& L2);
int a[] = {1, 4, 7, 8, 9,11};
int b[] = {2, 4, 5, 6, 7, 8};

int main()
{
    HeaderList* l1 = buildList(a, sizeof a / 4);
    HeaderList* l2 = buildList(b, sizeof b / 4);
    Print(l1);
    Print(l2);
    HeaderList* ans = Merge_Decline(l1, l2);
    Print(ans);
    return 0;
}

HeaderList* Merge_Decline(HeaderList*& L1, HeaderList*& L2)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L1->head->link;
    Node* q = L2->head->link;
    while (p && q)
    {
        Node* pne = p->link, *qne = q->link;
        if (p->element < q->element)
        {
            p->link = L->head->link;
            L->head->link = p;
            p = pne;
        }
        else
        {
            q->link = L->head->link;
            L->head->link = q;
            q = qne;
        }
    }
    while (p)
    {
        Node* tmp = p;
        p = p->link;
        tmp->link = L->head->link;
        L->head->link = tmp;
    }
    while (q)
    {
        Node* tmp = q;
        q = q->link;
        tmp->link = L->head->link;
        L->head->link = tmp;
    }
    return L;
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p14

```c++
/*
 * p14
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
HeaderList* Create_common(HeaderList*& L1, HeaderList*& L2);
int a[] = {1, 4, 7, 8, 9,11};
int b[] = {2, 4, 5, 6, 7, 8};

int main()
{
    HeaderList* l1 = buildList(a, sizeof a / 4);
    HeaderList* l2 = buildList(b, sizeof b / 4);
    Print(l1);
    Print(l2);
    HeaderList* ans = Create_common(l1, l2);
    Print(ans);
    return 0;
}

HeaderList* Create_common(HeaderList*& L1, HeaderList*& L2)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L1->head->link;
    Node* q = L2->head->link;
    while (p && q)
    {
        if (p->element == q->element)
        {
            Node* node = new Node;
            node->element = p->element;
            node->link = L->head->link;
            L->head->link = node;
            p = p->link;
            q = q->link;
        }
        else if (p->element < q->element)
            p = p->link;
        else
            q = q->link;
    }
    return L;
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
    return true;
}
```

#### p15

```c++
/*
 * p15
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
bool Intersection(HeaderList*& L1, HeaderList*& L2);
int a[] = {1, 4, 7, 8, 9,11};
int b[] = {2, 4, 5, 6, 7, 8};

int main()
{
    HeaderList* l1 = buildList(a, sizeof a / 4);
    HeaderList* l2 = buildList(b, sizeof b / 4);
    Print(l1);
    Print(l2);
    Intersection(l1, l2);
    Print(l1);
    return 0;
}

bool Intersection(HeaderList*& L1, HeaderList*& L2)
{
    Node* p = L1->head;
    Node* q = L2->head;
    while (p->link && q->link)
    {
        if (p->link->element == q->link->element)
        {
            p = p->link;
            Node* tmp = q->link;
            q->link = tmp->link;
            free(tmp);
        }
        else if (p->link->element < q->link->element)
        {
            Node* tmp = p->link;
            p->link = tmp->link;
            free(tmp);
        }
        else
        {
            Node* tmp = q->link;
            q->link = tmp->link;
            free(tmp);
        }
    }
    while (p->link)
    {
        Node* tmp = p->link;
        p->link = tmp->link;
        free(tmp);
    }
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
    return true;
}
```

#### p16

```c++
/*
 * p15
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
bool Is_sub(HeaderList*& L1, HeaderList*& L2);
int a[] = {5, 6, 7};
int b[] = {2, 4, 5, 6, 7, 8};

int main()
{
    HeaderList* l1 = buildList(a, sizeof a / 4);
    HeaderList* l2 = buildList(b, sizeof b / 4);
    Print(l1);
    Print(l2);
    if (Is_sub(l1, l2))
        puts("YES");
    else
        puts("NO");
    return 0;
}

bool Is_sub(HeaderList*& L1, HeaderList*& L2)
{
    Node* p = L1->head->link;
    Node* q = L2->head->link;
    while (p && q)
    {
        if (p->element == q->element)
            break;
        else if (p->element > q->element)
            q = q->link;
        else
            p = p->link;
    }
    while (p)
    {
        if (p->element != q->element)
            return false;
        p = p->link;
        q = q->link;
    }
    return true;
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
    return true;
}
```

#### p17

```c++
/*
 * p17
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* pre, * ne;
};
struct HeaderList
{
    Node* head;
    int length;
};
void Print(HeaderList* L);
bool Init(HeaderList* L);
HeaderList* BuildList(int a[], int n);
bool is_symmetric(HeaderList* L);
int a[] = {1, 2, 3, 4, 5, 4, 3, 2, 1};

int main()
{
    HeaderList* L = BuildList(a, sizeof a / 4);
    Print(L);
    if (is_symmetric(L))
        puts("YES");
    else
        puts("NO");
    return 0;
}

bool is_symmetric(HeaderList* L)
{
    Node* p = L->head->ne;
    Node* q = L->head->pre;
    while (p != q)
    {
        if (p->element != q->element)
            return false;
        p = p->ne;
        q = q->pre;
    }
    return true;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->ne = L->head;
    L->head->pre = L->head;
    L->length = 0;
    return true;
}

HeaderList* BuildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L->head;
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        node->ne = p->ne;
        node->pre = p;
        p->ne = node;
        p = p->ne;
        L->head->pre = node;
    }
    return L;
}

void Print(HeaderList* L)
{
    Node *p = L->head->ne;
    while (p != L->head)
    {
        cout << p->element << " ";
        p = p->ne;
    }
    puts("");
}
```

#### p18

```c++
/*
 * p18
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};
void Print(HeaderList* L);
bool Init(HeaderList* L);
void Merge(HeaderList* l1, HeaderList* l2);
HeaderList* BuildList(int a[], int n);

int a[] = {1, 2, 3, 4, 5, 4, 3, 2, 1};
int b[] = {3, 1, 2, 3, 5};
int main()
{
    HeaderList* L1 = BuildList(a, sizeof a / 4);
    Print(L1);
    HeaderList* L2 = BuildList(b, sizeof b / 4);
    Print(L2);
    Merge(L1, L2);
    Print(L1);
    return 0;
}

void Merge(HeaderList* l1, HeaderList* l2)
{
    Node* p = l1->head->link;
    Node* q = l2->head->link;
    while (p->link != l1->head)
        p = p->link;
    while (q->link != l2->head)
        q = q->link;
    p->link = l2->head->link;
    q->link = l1->head;
}


bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = L->head;
    L->length = 0;
    return true;
}

HeaderList* BuildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L->head;
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        node->link = p->link;
        p->link = node;
        p = p->link;
    }
    return L;
}

void Print(HeaderList* L)
{
    Node *p = L->head->link;
    while (p != L->head)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
}
```

#### p19

```c++
/*
 * p19
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};
void Print(HeaderList* L);
bool Init(HeaderList* L);
void Find_min(HeaderList* L);
HeaderList* BuildList(int a[], int n);

int a[] = {4, 6, 3, 9, 5, 4, 15, 2, 1};

int main()
{
    HeaderList* L1 = BuildList(a, sizeof a / 4);
    Print(L1);
    Find_min(L1);
    return 0;
}

void Find_min(HeaderList* L)
{
    Node* p = L->head->link;
    Node* pre = L->head;
    while (L->head->link != L->head)
    {
        p = L->head->link;
        pre = L->head;
        Node* minval = L->head->link;
        Node* minpre = L->head;
        while (p != L->head)
        {
            if (p->element < minval->element)
            {
                minval = p;
                minpre = pre;
            }
            pre = p;
            p = p->link;
        }
        cout << minval->element << endl;
        minpre->link = minval->link;
        free(minval);
    }
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = L->head;
    L->length = 0;
    return true;
}

HeaderList* BuildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L->head;
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        node->link = p->link;
        p->link = node;
        p = p->link;
    }
    return L;
}

void Print(HeaderList* L)
{
    Node *p = L->head->link;
    while (p != L->head)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
}
```

#### p20



```c++
/*
 * p20
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* pre, * ne;
    int freq;
};
struct HeaderList
{
    Node* head;
    int length;
};
void Print(HeaderList* L);
bool Init(HeaderList* L);
HeaderList* BuildList(int a[], int n);
Node* Locate(HeaderList* L, int x);
int a[] = {1, 2, 3, 4, 5, 4, 3, 2, 1};

int main()
{
    HeaderList* L = BuildList(a, sizeof a / 4);
    Print(L);
    Node* k = Locate(L, 2);
    if (k)
        puts("Locat success");
    Print(L);
    return 0;
}

Node* Locate(HeaderList* L, int x) {
    Node *p = L->head->ne;
    while (p && p->element != x)
        p = p->ne;
    if (!p)
        return NULL;
    else
    {
        ++ p->freq;
        p->pre->ne = p->ne;
        p->ne->pre = p->pre;
        p->ne = p->pre = NULL;
        Node* q = L->head->ne;
        while (q && q->freq > p->freq)
            q = q->ne;
        p->ne = q;
        p->pre = q->pre;
        q->pre->ne = p;
        q->pre = p;
    }
    return p;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->ne = NULL;
    L->head->pre = NULL;
    L->length = 0;
    return true;
}

HeaderList* BuildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L->head;
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        node->freq = 0;
        node->ne = p->ne;
        node->pre = p;
        p->ne = node;
        p = p->ne;
    }
    return L;
}

void Print(HeaderList* L)
{
    Node *p = L->head->ne;
    while (p)
    {
        cout << p->element << " ";
        p = p->ne;
    }
    puts("");
}
```

#### p21

```c++
/*
 * p21
 * 算法设计基本思想，遍历整个链表，并记录遍历的节点个数，若节点个数超过链表长度则有环，否则没有
 * 时间复杂度：O(N)
 * 空间复杂度：O(1)
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct SingleList
{
    Node* first;
    int length;
};
bool Init(SingleList* L); // 初始化单链表
bool Print(SingleList* L); // 输出
SingleList* BuildList(int a[], int n);
bool Is_loop(SingleList* L);
int a[] = {1, 2, 3, 4, 5, 4, 3, 2, 1};

int main()
{
    SingleList* singleList = BuildList(a, sizeof a / 4);
    Print(singleList);
//    Node* p = singleList->first;
//    while (p->link)
//        p = p->link;
//    p->link = singleList->first;
    if (Is_loop(singleList))
        puts("YES");
    else
        puts("NO");
    return 0;
}

bool Init(SingleList* L)
{
    L->first = NULL;
    L->length = 0;
    return true;
}
bool Is_loop(SingleList* L)
{
    Node* p = L->first;
    int num = 0;
    while (p)
    {
        ++num;
        p = p->link;
        if (num > L->length)
            return true;
    }
    return false;
}
SingleList* BuildList(int a[], int n)
{
    SingleList* L = new SingleList;
    Init(L);
    Node* p;
    for (int i = 0; i < n; ++ i)
    {
        Node *node = new Node;
        node->element = a[i];
        node->link = NULL;
        if (i == 0)
        {
            L->first = node;
           p = L->first;
        }
        else
        {
            node->link = p->link;
            p->link = node;
            p = p->link;
        }
    }
    L->length = n;
    return L;
}

bool Print(SingleList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->first;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}
```

#### p22

```c++
/*
 * p22
 * 算法基本思想：设置两个指针，起始的时候都指向第一个节点，先将其中一个节点移动到第k个元素，
 * 然后同时移动两个指针，当另外一个指针也移动到最后一个节点的时候，便能找到倒数第k个元素
 * 时间复杂度：O(N)
 * 空间复杂度：O(1)
 */

#include <iostream>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};
void Print(HeaderList* L);
bool Init(HeaderList* L);
Node* Find_k(HeaderList* L, int k);
HeaderList* BuildList(int a[], int n);
int a[] = {1, 2, 3, 9, 5, 7, 3, 2, 1};

int main()
{
    HeaderList* L = BuildList(a, sizeof a / 4);
    int k;
    cin >> k;
    cout << "倒数第" << k << "个元素为： " << Find_k(L, k)->element << endl;
    return 0;
}


bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

Node* Find_k(HeaderList* L, int k)
{
    Node* p = L->head->link;
    Node* q = L->head->link;
    while (k --)
        p = p->link;
    while (p)
    {
        p = p->link;
        q = q->link;
    }
    return q;
}

HeaderList* BuildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    Node* p = L->head;
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        node->link = p->link;
        p->link = node;
        p = p->link;
    }
    return L;
}

void Print(HeaderList* L)
{
    Node *p = L->head->link;
    while (p != L->head)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
}
```

#### p23

```c++
/*
 * p23
 * 和p8一样的思路
 */

#include <iostream>
using namespace std;
struct Node
{
    char element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(string s, int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
bool Destory(HeaderList* L); // 销毁单链表
Node* Common_node(HeaderList* L1, HeaderList* L2);
string a = "loading";
string b = "being";

int main()
{
    HeaderList* L1 = buildList(a, a.length());
    HeaderList* L2 = buildList(b, b.length());
    Print(L1);
    Print(L2);
    Node* node = Common_node(L1, L2);
    if (node)
        while (node)
        {
            cout << node->element << " ";
            node = node->link;
        }
    else
        puts("无公共节点");
    return 0;
}

HeaderList* buildList(string s, int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = s[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

Node* Common_node(HeaderList* L1, HeaderList* L2) {
    int dist = 0;
    int l1 = L1->length, l2 = L2->length;
    Node *longlist, *shortlist;
    if (l1 > l2) {
        longlist = L1->head->link;
        shortlist = L2->head->link;
        dist = l1 - l2;
    } else {
        longlist = L2->head->link;
        shortlist = L1->head->link;
        dist = l2 - l1;
    }
    while (dist--)
        longlist = longlist->link;
    while (longlist)
    {
        if (longlist->element == shortlist->element && longlist->link->element == shortlist->link->element)
            return longlist;
        else
        {
            longlist = longlist->link;
            shortlist = shortlist->link;
        }
    }
    return NULL;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}

bool Destory(HeaderList* L)
{
    Node* p;
    while (L->head)
    {
        p = L->head->link;
        free(L->head);
        L->head = p;
    }
}
```

#### p24

```c++
/*
 * p24
 */

#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
void Del_list_abs_val(HeaderList* L, int n);
int a[] = {-3, 4, -1, 6, 7, 1, 8, 3};

int main()
{
    HeaderList* L = buildList(a, sizeof a / 4);
    Print(L);
    int x;
    cin >> x;
    Del_list_abs_val(L, x);
    Print(L);
    return 0;
}

void Del_list_abs_val(HeaderList* L, int n)
{
    int *cnt = new int[n + 1];
    memset(cnt, 0, (sizeof(int)) * (n + 1));
    Node* p = L->head->link;
    Node* pre = L->head;
    while (p)
    {
        if (! cnt[abs(p->element)])
        {
            ++ cnt[abs(p->element)];
            pre = p;
            p = p->link;
        }
        else
        {
            Node* tmp = p;
            pre->link = tmp->link;
            p = tmp->link;
            free(tmp);
        }
    }
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}
```

#### p25

```c++
/*
 * p25
 */

#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;
struct Node
{
    int element;
    Node* link;
};
struct HeaderList
{
    Node* head;
    int length;
};

bool Init(HeaderList* L); // 初始化单链表
HeaderList* buildList(int a[], int n); //依据一个数组的元素创建链表
bool Print(HeaderList* L); // 输出
void Re_sort(HeaderList* L);
int a[] = {1, 4, 3, 6, 7, 1, 8, 3};

int main()
{
    HeaderList* L = buildList(a, sizeof a / 4);
    Print(L);
    Re_sort(L);
    Print(L);
    return 0;
}

void Re_sort(HeaderList* L)
{
    Node* p = L->head->link;
    Node* q = L->head->link;
    while (q->link)
    {
        p = p->link;
        q = q->link;
        if (q->link)
            q = q->link;
    }
    Node* l2 = p->link;
    p->link = NULL;
    while (l2)
    {
        Node* tmp = l2->link;
        l2->link = p->link;
        p->link = l2;
        l2 = tmp;
    }
    Node* l1 = L->head->link;
    q = p->link;
    p->link = NULL;
    while (q)
    {
        Node* r = q->link;
        q->link = l1->link;
        l1->link = q;
        l1 = q->link;
        q = r;
    }
}

HeaderList* buildList(int a[], int n)
{
    HeaderList* L = new HeaderList;
    Init(L);
    for (int i = 0; i < n; ++ i)
    {
        Node* node = new Node;
        node->element = a[i];
        Node* p = L->head;
        while (p->link)
            p = p->link;
        node->link = p->link;
        p->link = node;
    }
    L->length = n;
    return L;
}

bool Init(HeaderList* L)
{
    L->head = new Node;
    if (!L->head)
        return false;
    L->head->link = NULL;
    L->length = 0;
    return true;
}

bool Print(HeaderList* L)
{
    Node* p;
    if (!L->length)
        return false;
    p = L->head->link;
    while(p)
    {
        cout << p->element << " ";
        p = p->link;
    }
    puts("");
    return true;
}
```

## 第三章

### 3.1.4

#### p03

```c++
/*
 * p03
 */
#include <iostream>
using namespace std;
string str[] = {"IOIIOIOO", "IOOIOIIO", "IIIOIOIO", "IIIOOIOO"};

int main()
{

    for (int i = 0; i < 4; ++ i)
    {
        int ans = 0;
        bool flag = true;
        for (int j = 0; j < str[i].size(); ++ j)
        {
            if (str[i][j] == 'I')
                ++ ans;
            else if (str[i][j] == 'O')
                -- ans;
            if (ans < 0)
                flag = false;
        }
        if (flag && !ans)
            cout << char('A' + i) << "  合格" << endl;
        else
            cout << char('A' + i) << "  不合格" << endl;
    }
    return 0;
}
```

#### p04

```c++
/*
 * p04
 */

#include <iostream>
using namespace std;
typedef char ElemType;
struct Node
{
    ElemType data;
    Node *link;
};
struct LinkStack
{
    Node *linkStack;
    int lenght;
};
void Init(LinkStack &s);
bool IsEmpty(LinkStack &s);
bool GetTop(LinkStack &s, ElemType &x);
bool Pop(LinkStack &s, ElemType &x);
bool Push(LinkStack &s, ElemType x);
bool Is_symmetry(string str);

int main()
{
    string str;
    cin >> str;
    if (Is_symmetry(str))
        puts("对称");
    else
        puts("不对称");
    return 0;
}

void Init(LinkStack &s)
{
    s.linkStack = NULL;
    s.lenght = 0;
}

bool IsEmpty(LinkStack &s)
{
    return s.linkStack == NULL;
}

bool GetTop(LinkStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.linkStack->data;
    return true;
}

bool Pop(LinkStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.linkStack->data;
    Node* tmp = s.linkStack;
    s.linkStack = s.linkStack->link;
    free(tmp);
    return true;
}

bool Push(LinkStack &s, ElemType x)
{
    Node *node = new Node;
    node->data = x;
    node->link = s.linkStack;
    s.linkStack = node;
    return true;
}

bool Is_symmetry(string str)
{
    LinkStack s;
    Init(s);
    for (int i = 0; i < str.size(); ++ i)
        Push(s, str[i]);
    int idx = 0;
    while (!IsEmpty(s))
    {
        char x;
        Pop(s, x);
        if (x != str[idx ++])
            return false;
    }
    return true;
}
```

#### p05

```c++
/*
 * p05
 */
#include <iostream>
using namespace std;
typedef int ElemType;

struct SqStack
{
    int top[3];
    int MaxSize;
    ElemType *data;
};
void Init(SqStack &s, int maxsize);
bool IsEmpty(SqStack &s, int i);
bool GetTop(SqStack &s, int i, ElemType &x);
bool Push(SqStack &s, int i, ElemType x);
bool Pop(SqStack &s, int i, ElemType &x);

int main()
{
    SqStack s;
    Init(s, 20);
    Push(s, 1, 2);
    Push(s, 1, 8);
    Push(s, 2, 4);
    int x;
    GetTop(s, 1, x);
    cout << x << endl;
    return 0;
}

void Init(SqStack &s, int maxsize)
{
    s.top[1] = -1;
    s.top[2] = maxsize;
    s.data = new ElemType[maxsize];
    s.MaxSize = maxsize;
}

bool IsEmpty(SqStack &s, int i)
{
    switch (i) {
        case 1:
            if (s.top[1] + 1 != s.top[2])
                return false;
            else
                return true;
        case 2:
            if (s.top[2] - 1 == s.top[1])
                return true;
            else
                return false;
    }
}

bool GetTop(SqStack &s, int i, ElemType &x)
{
    switch(i){
        case 1:
            if (s.top[1] != -1)
            {
                x = s.data[s.top[1]];
                return true;
            }
            else
                return false;
        case 2:
            if (s.top[2] != s.MaxSize)
            {
                x = s.data[s.top[2]];
                return true;
            }
            else
                return false;
    }
}

bool Push(SqStack &s, int i, ElemType x)
{
    if (i < 0 || i > 2)
        return false;
    if (s.top[1] + 1 == s.top[2])
    {
        puts("栈满");
        return false;
    }
    switch(i) {
        case 1:
            s.data[++ s.top[1]] = x;
            return true;
            break;
        case 2:
            s.data[-- s.top[2]] = x;
            return true;
            break;
    }
}

bool Pop(SqStack &s, int i, ElemType &x)
{
    if (i < 0 || i > 2)
        return false;
    switch(i) {
        case 1:
            if (s.top[1] == -1)
            {
                puts("栈空");
                return false;
            }
            else
            {
                x = s.data[s.top[1] --];
                return true;
            }
        case 2:
            if (s.top[2] == s.MaxSize)
            {
                puts("栈空");
                return false;
            }
            else
            {
                x = s.data[s.top[2] ++];
                return true;
            }
    }
}
```

### 3.2.5

#### p01

```c++
//
// p01
//
#include <iostream>
#define MaxSize 10
using namespace std;
typedef int ElemType;
struct SqQueue
{
    int front, rear;
    ElemType *data;
    bool tag;
};
void Init(SqQueue &q);
bool IsEmpty(SqQueue &q);
bool EnQueue(SqQueue &q, ElemType x);
bool DeQueue(SqQueue &q, ElemType &x);

int main()
{
    SqQueue q;
    Init(q);
    if (!IsEmpty(q))
        puts("队列非空");
    EnQueue(q, 10);
    EnQueue(q, 20);
    EnQueue(q, 30);

    int x;
    puts("出队");
    DeQueue(q, x);
    cout << x << endl;
    DeQueue(q, x);
    cout << x << endl;
    DeQueue(q, x);
    cout << x << endl;
    if (IsEmpty(q))
        puts("队列空");
    return 0;
}

void Init(SqQueue &q)
{
    q.data = new ElemType[MaxSize];
    q.front = q.rear = 0;
    q.tag = 0;
}

bool IsEmpty(SqQueue &q)
{
    if (q.front == q.rear && q.tag == 0)
        return true;
    return false;
}

bool EnQueue(SqQueue &q, ElemType x) {
    if (q.front == q.rear && q.tag == 1)
    {
        puts("队列满");
        return false;
    }
    q.data[q.rear] = x;
    q.rear = (q.rear + 1 + MaxSize) % MaxSize;
    if (q.front == q.rear)
        q.tag = 1;
    return true;
}

bool DeQueue(SqQueue &q, ElemType &x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[q.front];
    q.front = (q.front + 1 + MaxSize) % MaxSize;
    if (q.front == q.rear)
        q.tag = 0;
    return true;
}

```

#### p02

```c++
/*
 * p02
 */
#include <iostream>
#define MaxSize 100
using namespace std;
typedef int ElemType;
struct SqQueue
{
    int front, rear;
    ElemType *data;
};
void Init(SqQueue &q);
bool IsEmpty(SqQueue &q);
bool EnQueue(SqQueue &q, ElemType x);
bool DeQueue(SqQueue &q, ElemType &x);


struct SqStack
{
    int top;
    int Maxsize;
    ElemType *data;
};
void Initstack(SqStack &s, int maxsize);
void Destory(SqStack &s);
bool IsEmpty(SqStack &s);
bool IsFull(SqStack &s);
bool GetTop(SqStack &s, ElemType &x);
bool Push(SqStack &s, ElemType x);
bool Pop(SqStack &s, ElemType &x);


int main()
{
    SqQueue q;
    Init(q);
    SqStack s;
    Initstack(s, MaxSize);
    puts("队列元素为：");
    for (int i = 1; i < 10; ++ i)
    {
        cout << i << " ";
        EnQueue(q, i);
    }
    puts("");
    while (!IsEmpty(q))
    {
        int x;
        DeQueue(q, x);
        Push(s, x);
    }
    while (!IsEmpty(s))
    {
        int x;
        Pop(s, x);
        cout << x << " ";
    }
    return 0;
}

void Init(SqQueue &q)
{
    q.front = q.front = 0;
    q.data = new ElemType[MaxSize];
}

bool IsEmpty(SqQueue &q)
{
    if (q.front == q.rear)
        return true;
    return false;
}

bool EnQueue(SqQueue &q, ElemType x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[q.rear ++] = x;
    return true;
}

bool DeQueue(SqQueue &q, ElemType &x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[q.front ++];
    return true;
}

void Initstack(SqStack &s, int maxsize)
{
    s.data = new ElemType [maxsize];
    s.Maxsize = maxsize;
    s.top = -1;
}

void Destory(SqStack &s)
{
    s.Maxsize = -1;
    free(s.data);
    s.top = -1;
}

bool IsEmpty(SqStack &s)
{
    return s.top == -1;
}

bool IsFull(SqStack &s)
{
    return s.top == s.Maxsize - 1;
}

bool GetTop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

bool Push(SqStack &s, ElemType x)
{
    if (IsFull(s))
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

```

#### p03

```c++
/*
 * p03
 */
#include <iostream>
using namespace std;
typedef int ElemType;

struct SqStack
{
    int top;
    int MaxSize;
    ElemType *data;
};
void Init(SqStack &s, int maxsize);
bool IsEmpty(SqStack &s);
bool IsFull(SqStack &s);
bool Push(SqStack &s, ElemType x);
bool Pop(SqStack &s, ElemType &x);
bool EnQueue(SqStack &s1, SqStack &s2, ElemType x);
bool DeQueue(SqStack &s1, SqStack &s2, ElemType &x);
bool QueueEmpty(SqStack &s1, SqStack &s2);

int main()
{
    SqStack s1, s2;
    Init(s1, 10);
    Init(s2, 10);
    EnQueue(s1, s2, 4);
    EnQueue(s1, s2, 10);
    EnQueue(s1, s2, 100);
    int x;
    DeQueue(s1, s2, x);
    cout << x << endl;
    cout << QueueEmpty(s1, s2) << endl;

    return 0;
}

bool EnQueue(SqStack &s1, SqStack &s2, ElemType x)
{
    if (!IsFull(s1))
    {
        Push(s1, x);
        return true;
    }
    if (IsFull(s1) && !IsEmpty(s2))
    {
        puts("队列满");
        return false;
    }
    if (IsFull(s1) && IsEmpty(s2))
    {
        while (!IsEmpty(s1))
        {
            int x;
            Pop(s1, x);
            Push(s2, x);
        }
    }
    Push(s1, x);
    return true;

}

bool DeQueue(SqStack &s1, SqStack &s2, ElemType &x)
{
    if (!IsEmpty(s2))
    {
        Pop(s2, x);
        return true;
    }
    else if (IsEmpty(s1))
    {
        printf("队列为空");
        return false;
    }
    else
    {
        while (!IsEmpty(s1))
        {
            int y;
            Pop(s1, y);
            Push(s2, y);
        }
        Pop(s2, x);
        return true;
    }
}

bool QueueEmpty(SqStack &s1, SqStack &s2)
{
    if (IsEmpty(s1) && IsEmpty(s2))
        return true;
    return false;
}

void Init(SqStack &s, int maxsize)
{
    s.data = new ElemType [maxsize];
    s.MaxSize = maxsize;
    s.top = -1;
}

bool IsEmpty(SqStack &s)
{
    return s.top == -1;
}

bool IsFull(SqStack &s)
{
    return s.top == s.MaxSize - 1;
}

bool Push(SqStack &s, ElemType x)
{
    if (IsFull(s))
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

```

#### p04

```c++
/*
 * p04
 * 其实就是利用循环链表去实现队列
 */

#include <iostream>
using namespace std;
typedef int ElemType;
struct Node
{
    ElemType data;
    Node* link;
};
struct Queue
{
    Node* front, *rear;
};
bool Init(Queue &q);
bool IsEmpty(Queue &q);
bool IsFull(Queue &q);
bool EnQueue(Queue &q, ElemType x);
bool DeQueue(Queue &q, ElemType  &x);

int main()
{
    Queue q;
    Init(q);
    if (IsEmpty(q))
        puts("空");
    else
        puts("非空");
    EnQueue(q, 10);
    EnQueue(q, 20);
    EnQueue(q, 30);
    ElemType x;
    if (IsFull(q))
        puts("YES");
    else
        puts("NO");
    DeQueue(q, x);
    cout << x << endl;
    DeQueue(q, x);
    cout << x << endl;
    if (IsEmpty(q))
        puts("空");
    else
        puts("非空");

    return 0;
}

bool Init(Queue &q)
{
    q.front = new Node;
    q.rear = q.front;
    q.rear->link = q.front;
}

bool IsEmpty(Queue &q)
{
    if (q.rear == q.front)
        return true;
    return false;
}

bool IsFull(Queue &q)
{
    if (q.rear->link == q.front)
        return true;
    return false;
}

bool EnQueue(Queue &q, ElemType x)
{
    if (q.rear->link == q.front)
    {
        Node *node = new Node;
        node->data = x;
        q.rear->link = node;
        q.rear = node;
        q.rear->link = q.front;
        return true;
    }
    else
    {
        q.rear->link->data = x;
        q.rear = q.rear->link;
        return true;
    }
}

bool DeQueue(Queue &q, ElemType  &x)
{
    if (q.rear == q.front)
        return false;
    x = q.front->link->data;
    q.front = q.front->link;
    return true;
}
```

### 3.3.6

#### p01

```c++
/*
 * p01
 */
#include <iostream>
#include <cstring>
#include <cstdio>
#include <iomanip>
using namespace std;
typedef char ElemType;

struct SqStack
{
    int top;
    int MaxSize;
    ElemType *data;
};
void Init(SqStack &s, int maxsize);
void Destory(SqStack &s);
bool IsEmpty(SqStack &s);
bool IsFull(SqStack &s);
bool GetTop(SqStack &s, ElemType &x);
bool Push(SqStack &s, ElemType x);
bool Pop(SqStack &s, ElemType &x);
bool BracketCheck(char *str);

int main()
{
    char str[100];
    gets(str);
    if (BracketCheck(str))
        puts("匹配");
    else
        puts("不匹配");
    return 0;
}
bool BracketCheck(char *str)
{
    SqStack s;
    Init(s, 100);
    int idx = 0;
    while (str[idx] != '\0')
    {
        if (str[idx] == '(' || str[idx] == '[' || str[idx] == '{')
        {
            Push(s, str[idx]);
            ++ idx;
        }
        else if (str[idx] == ')')
        {
            char ch;
            Pop(s, ch);
            if (ch != '(')
                return false;
            ++ idx;
        }
        else if (str[idx] == ']')
        {
            char ch;
            Pop(s, ch);
            if (ch != '[')
                return false;
            ++ idx;
        }
        else if (str[idx] == '}')
        {
            char ch;
            Pop(s, ch);
            if (ch != '{')
                return false;
            ++ idx;
        }
    }
    if (IsEmpty(s))
        return true;
    return false;
}

void Init(SqStack &s, int maxsize)
{
    s.data = new ElemType [maxsize];
    s.MaxSize = maxsize;
    s.top = -1;
}

void Destory(SqStack &s)
{
    s.MaxSize = -1;
    free(s.data);
    s.top = -1;
}

bool IsEmpty(SqStack &s)
{
    return s.top == -1;
}

bool IsFull(SqStack &s)
{
    return s.top == s.MaxSize - 1;
}

bool GetTop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

bool Push(SqStack &s, ElemType x)
{
    if (IsFull(s))
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

```

#### p02

```c++
/*
 * p02
 */
/*
 * p01
 */
#include <iostream>
#include <cstring>
#include <cstdio>
#include <iomanip>
using namespace std;
typedef char ElemType;

struct SqStack
{
    int top;
    int MaxSize;
    ElemType *data;
};
void Init(SqStack &s, int maxsize);
void Destory(SqStack &s);
bool IsEmpty(SqStack &s);
bool IsFull(SqStack &s);
bool GetTop(SqStack &s, ElemType &x);
bool Push(SqStack &s, ElemType x);
bool Pop(SqStack &s, ElemType &x);
void modify_train(char *str);

int main()
{
    char str[100];
    gets(str);
    modify_train(str);
    return 0;
}

void modify_train(char *str)
{
    SqStack s;
    Init(s, 100);
    char ans[100];
    int i = 0;
    int idx = 0;
    while (str[idx] != '\0')
    {
        if (str[idx] == 'S')
        {
            ans[i ++] = str[idx ++];
            continue;
        }
        else if (str[idx] == 'H')
        {
            Push(s, str[idx]);
            ++idx;
        }
    }
    while (!IsEmpty(s))
        Pop(s, ans[i ++]);
    for (int j = 0; j < i; ++ j)
        cout << ans[j];
}

void Init(SqStack &s, int maxsize)
{
    s.data = new ElemType [maxsize];
    s.MaxSize = maxsize;
    s.top = -1;
}

void Destory(SqStack &s)
{
    s.MaxSize = -1;
    free(s.data);
    s.top = -1;
}

bool IsEmpty(SqStack &s)
{
    return s.top == -1;
}

bool IsFull(SqStack &s)
{
    return s.top == s.MaxSize - 1;
}

bool GetTop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

bool Push(SqStack &s, ElemType x)
{
    if (IsFull(s))
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

```

#### p03

```c++
/*
 * p3
 */
#include <iostream>
#include <cstring>
#include <cstdio>
#include <iomanip>
using namespace std;
typedef struct {
    int val, idx;
}ElemType;

struct SqStack
{
    int top;
    int MaxSize;
    ElemType *data;
};
void Init(SqStack &s, int maxsize);
bool IsEmpty(SqStack &s);
bool IsFull(SqStack &s);
bool GetTop(SqStack &s, ElemType &x);
bool Push(SqStack &s, ElemType x);
bool Pop(SqStack &s, ElemType &x);
int P_n(double x, int n);

int main()
{
    double x;
    int n;
    cin >> x >> n;
    cout << P_n(x, n) << endl;
    return 0;
}

int P_n(double x, int n)
{
    SqStack s;
    Init(s, 100);
    double v1 = 1, v2 = 2 * x;
    for (int i = n; i >= 2; --i)
        Push(s, {0, i});
    while (!IsEmpty(s))
    {
        ElemType node;
        GetTop(s, node);
        node.val = 2 * x * v2 - 2 * (node.idx - 1) * v1;
        v1 = v2;
        v2 = node.val;
        Pop(s, node);
    }
    if (n == 0)
        return v1;
    return v2;
}
void Init(SqStack &s, int maxsize)
{
    s.data = new ElemType [maxsize];
    s.MaxSize = maxsize;
    s.top = -1;
}

bool IsEmpty(SqStack &s)
{
    return s.top == -1;
}

bool IsFull(SqStack &s)
{
    return s.top == s.MaxSize - 1;
}

bool GetTop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

bool Push(SqStack &s, ElemType x)
{
    if (IsFull(s))
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(SqStack &s, ElemType &x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}
```

#### p04

```c++
/*
 * p04
 */
#include <iostream>
#define MaxSize 100
using namespace std;
typedef char ElemType;
struct SqQueue
{
    int front, rear;
    ElemType *data;
};
void Init(SqQueue &q);
bool IsEmpty(SqQueue &q);
bool EnQueue(SqQueue &q, ElemType x);
bool DeQueue(SqQueue &q, ElemType &x);
bool manager(SqQueue &q1, SqQueue &q2);

int main()
{
    SqQueue q1, q2;
    Init(q1);
    Init(q2);
    for (int i = 0; i < 5; ++ i)
        EnQueue(q1, 'H');
    for (int j = 0; j < 5; ++ j)
        EnQueue(q2, 'K');



    manager(q1, q2);

    return 0;
}

bool manager(SqQueue &q1, SqQueue &q2)
{
    // q2 客车 q1 货车
    SqQueue ans;
    Init(ans);
    int num = 0, idx = 0;
    while (num < 10)
    {
        if (!IsEmpty(q2) && idx < 4)
        {
            ElemType x;
            DeQueue(q2, x);
            EnQueue(ans, x);
            ++ idx;
            ++ num;
        }
        else if (idx == 4 && !IsEmpty(q1))
        {
            ElemType x;
            DeQueue(q1, x);
            EnQueue(ans, x);
            ++ num;
            idx = 0;
        }
        else
        {
            while (num < 10 && idx < 4 && !IsEmpty(q1))
            {
                ElemType x;
                DeQueue(q1, x);
                EnQueue(ans ,x);
                ++ num;
                ++ idx;
            }
            idx = 0;
        }
        if (IsEmpty(q1) && IsEmpty(q1))
            break;
    }
    while (!IsEmpty(ans))
    {
        ElemType x;
        DeQueue(ans, x);
        cout << x << " ";
    }
}

void Init(SqQueue &q)
{
    q.front = q.front = 0;
    q.data = new ElemType[MaxSize];
}

bool IsEmpty(SqQueue &q)
{
    if (q.front == q.rear)
        return true;
    return false;
}

bool EnQueue(SqQueue &q, ElemType x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[q.rear ++] = x;
    return true;
}

bool DeQueue(SqQueue &q, ElemType &x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[q.front ++];
    return true;
}

```

### 5.2.3

#### p05

```c++
/*
 * p05
 */

#include <iostream>
using namespace std;
struct SqTree
{
    int tree[12] = {-1, 1, 2, 3, -1, 4, -1, 5, -1, -1, 6, -1};
};
int Comm_ancestor(SqTree &t, int i, int j);

int main()
{
    SqTree s;
    int x, y;
    cin >> x >> y;
    cout << Comm_ancestor(s, x, y) << endl;
    return 0;
}

int Comm_ancestor(SqTree &t, int i, int j)
{
    if (t.tree[i] != -1 && t.tree[j] != -1)
    {
        while (i != j)
        {
            if (i > j)
                i /= 2;
            else
                j /= 2;
        }
        return t.tree[i];
    }
    return -1;
}
```

### 5.3.3

#### p03

```c++
/*
 * p03
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
};
struct Stack
{
    int top;
    TreeNode* data[MaxSize];
};
struct Queue
{
    int front, rear;
    TreeNode* data[MaxSize];
};
void InitStack(Stack &s);
bool IsEmpty(Stack &s);
bool Push(Stack &s, TreeNode* x);
bool Pop(Stack &s, TreeNode *&x);
bool GetTop(Stack &s, TreeNode *&x);

void InitQueue(Queue &q);
bool IsEmpty(Queue &q);
bool EnQueue(Queue &q, TreeNode *x);
bool DeQueue(Queue &q, TreeNode *&x);

void Init(Tree &tree);
TreeNode* CreateTree();
void epilogue1(TreeNode* r);

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout << "后序：";
    epilogue1(tree.root);
    return 0;
}

void InitStack(Stack &s)
{
    s.top = -1;
}

bool IsEmpty(Stack &s)
{
    return s.top == -1;
}

bool Push(Stack &s, TreeNode *x)
{
    if (s.top == MaxSize - 1)
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(Stack &s, TreeNode *&x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

bool GetTop(Stack &s, TreeNode *&x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

void InitQueue(Queue &q)
{
    q.front = q.rear = 0;
}

bool IsEmpty(Queue &q)
{
    return q.front == q.rear;
}

bool EnQueue(Queue &q, TreeNode *x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[q.rear ++] = x;
    return true;
}

bool DeQueue(Queue &q, TreeNode *&x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[q.front ++];
    return true;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}


void epilogue1(TreeNode* r)
{
    Stack s;
    InitStack(s);
    TreeNode *p = r;
    TreeNode *t = NULL;
    while (p || !IsEmpty(s))
    {
        if (p)
        {
            Push(s, p);
            p = p->leftson;
        }
        else
        {
            GetTop(s, p);
            if (p->rightson && p->rightson != t)
                p = p->rightson;
            else
            {
                Pop(s, p);
                cout << p->element << " ";
                t = p;
                p = NULL;
            }
        }
    }
}

```

#### p04

```c++
/*
 * p04
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
};
struct Stack
{
    int top;
    TreeNode* data[MaxSize];
};
struct Queue
{
    int front, rear;
    TreeNode* data[MaxSize];
};
void InitStack(Stack &s);
bool IsEmpty(Stack &s);
bool Push(Stack &s, TreeNode* x);
bool Pop(Stack &s, TreeNode *&x);
bool GetTop(Stack &s, TreeNode *&x);

void InitQueue(Queue &q);
bool IsEmpty(Queue &q);
bool EnQueue(Queue &q, TreeNode *x);
bool DeQueue(Queue &q, TreeNode *&x);

void Init(Tree &tree);
TreeNode* CreateTree();
void sequence(TreeNode* r);

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout << "后序：";
    sequence(tree.root);
    return 0;
}

void InitStack(Stack &s)
{
    s.top = -1;
}

bool IsEmpty(Stack &s)
{
    return s.top == -1;
}

bool Push(Stack &s, TreeNode *x)
{
    if (s.top == MaxSize - 1)
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(Stack &s, TreeNode *&x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

bool GetTop(Stack &s, TreeNode *&x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

void InitQueue(Queue &q)
{
    q.front = q.rear = 0;
}

bool IsEmpty(Queue &q)
{
    return q.front == q.rear;
}

bool EnQueue(Queue &q, TreeNode *x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[q.rear ++] = x;
    return true;
}

bool DeQueue(Queue &q, TreeNode *&x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[q.front ++];
    return true;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}

void sequence(TreeNode* r)
{
    Stack s;
    InitStack(s);
    Queue q;
    InitQueue(q);
    EnQueue(q, r);
    while (!IsEmpty(q))
    {
        TreeNode *tmp;
        DeQueue(q, tmp);
        Push(s, tmp);
        if (tmp->leftson)
            EnQueue(q, tmp->leftson);
        if (tmp->rightson)
            EnQueue(q, tmp->rightson);
    }
    while (!IsEmpty(s))
    {
        TreeNode *t;
        Pop(s, t);
        cout << t->element << " ";
    }
}
```

#### p05

```c++
/*
 * p05
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Queue
{
    int front, rear;
    TreeNode* data[MaxSize];
};
struct Tree
{
    TreeNode *root;
};
void InitQueue(Queue &q);
bool IsEmpty(Queue &q);
bool EnQueue(Queue &q, TreeNode *x);
bool DeQueue(Queue &q, TreeNode *&x);

void Init(Tree &tree);
TreeNode* CreateTree();
int Height(Tree &tree);

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout << "树的高度为：" << Height(tree) << endl;
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}


void InitQueue(Queue &q)
{
    q.front = q.rear = -1;
}

bool IsEmpty(Queue &q)
{
    return q.front == q.rear;
}

bool EnQueue(Queue &q, TreeNode *x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[++ q.rear] = x;
    return true;
}

bool DeQueue(Queue &q, TreeNode *&x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[++ q.front];
    return true;
}

int Height(Tree &tree)
{
    int height = 0;
    if (! tree.root)
        return 0;
    Queue q;
    InitQueue(q);
    int last = 0;
    EnQueue(q, tree.root);
    TreeNode *p;
    while (!IsEmpty(q))
    {
        DeQueue(q, p);
        if (p->leftson)
            EnQueue(q, p->leftson);
        if (p->rightson)
            EnQueue(q, p->rightson);
        if (q.front == last)
        {
            ++height;
            last = q.rear;
        }
    }
    return height;
}
```

#### p06

```c++
/*
 * p06
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
};

void Init(Tree &tree);
TreeNode* CreateTree(int pl, int pr, int il, int ir);
int porder[] = {2, 1, 6, 7, 5, 3};
int iorder[] = {1, 6, 2, 3, 5, 7};
void epilogue(TreeNode* r);

int main()
{
    Tree tree;
    Init(tree);
    tree.root = CreateTree(0, sizeof porder / 4 - 1, 0, sizeof iorder / 4 - 1);
    cout << "后序遍历为：";
    epilogue(tree.root);
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree(int pl, int pr, int il, int ir)
{
    if (pl > pr)
        return nullptr;
    Tree tree;
    Init(tree);
    tree.root = new TreeNode;
    tree.root->element = porder[pl];
    int k;
    for (int i = il; i <= ir; ++ i)
        if (iorder[i] == porder[pl])
        {
            k = i;
            break;
        }
    int numLtree = k - il;
    tree.root->leftson = CreateTree(pl + 1, pl + numLtree, il, k - 1);
    tree.root->rightson = CreateTree(pl + numLtree + 1, pr, k + 1, ir);
    return tree.root;
}

void epilogue(TreeNode* r)
{
    if (!r)
        return ;
    epilogue(r->leftson);
    epilogue(r->rightson);
    cout << r->element << " ";
}
```

#### p07

```c++
/*
 * p07
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Queue
{
    int front, rear;
    TreeNode* data[MaxSize];
};
struct Tree
{
    TreeNode *root;
};
void InitQueue(Queue &q);
bool IsEmpty(Queue &q);
bool EnQueue(Queue &q, TreeNode *x);
bool DeQueue(Queue &q, TreeNode *&x);

void Init(Tree &tree);
TreeNode* CreateTree();
bool IsCompleteTree(Tree &tree);
bool IsCompleteTree_v2(Tree &tree);
int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout << "判断方法1：";
    if (IsCompleteTree(tree))
        puts("是");
    else
        puts("不是");
    cout << "判断方法2：";
    if (IsCompleteTree_v2(tree))
        puts("是");
    else
        puts("不是");
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}


void InitQueue(Queue &q)
{
    q.front = q.rear = -1;
}

bool IsEmpty(Queue &q)
{
    return q.front == q.rear;
}

bool EnQueue(Queue &q, TreeNode *x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[++ q.rear] = x;
    return true;
}

bool DeQueue(Queue &q, TreeNode *&x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[++ q.front];
    return true;
}

bool IsCompleteTree(Tree &tree)
{
    if (! tree.root)
        return true;
    Queue q;
    bool leaf = false;
    InitQueue(q);
    EnQueue(q, tree.root);
    TreeNode *p;
    while (! IsEmpty(q))
    {
        DeQueue(q, p);
        if (leaf && (p->leftson || p->rightson) || (! p->leftson && p->rightson))
            return false;
        if (p->leftson)
            EnQueue(q, p->leftson);
        if (p->rightson)
            EnQueue(q, p->rightson);
        if ((p->leftson && ! p->rightson) || (! p->leftson && ! p->rightson))
            leaf = true;
    }
    return true;
}

bool IsCompleteTree_v2(Tree &tree)
{
    if (! tree.root)
        return true;
    Queue q;
    InitQueue(q);
    EnQueue(q, tree.root);
    TreeNode *p;
    int idx = 0;
    while (! IsEmpty(q))
    {
        DeQueue(q, p);
        if (p->element != -1)
        {
            if (p->leftson)
                EnQueue(q, p->leftson);
            else
            {
                TreeNode *tmp = new TreeNode{-1, NULL, NULL};
                EnQueue(q,tmp);
            }
            if(p->rightson)
                EnQueue(q, p->rightson);
            else
            {
                TreeNode *tmp = new TreeNode{-1, NULL, NULL};
                EnQueue(q,tmp);
            }
        }
        else
        {
            while (!IsEmpty(q))
            {
                DeQueue(q, p);
                if (p->element != -1)
                    return false;
            }
            return true;
        }
    }
    return true;
}

```

#### p08

```c++
/*
 * p08
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Queue
{
    int front, rear;
    TreeNode* data[MaxSize];
};
struct Tree
{
    TreeNode *root;
};
void InitQueue(Queue &q);
bool IsEmpty(Queue &q);
bool EnQueue(Queue &q, TreeNode *x);
bool DeQueue(Queue &q, TreeNode *&x);

void Init(Tree &tree);
TreeNode* CreateTree();
int cntNodeTwice(Tree &tree);

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout << "双分支节点个数为：" << cntNodeTwice(tree) << endl;
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}


void InitQueue(Queue &q)
{
    q.front = q.rear = -1;
}

bool IsEmpty(Queue &q)
{
    return q.front == q.rear;
}

bool EnQueue(Queue &q, TreeNode *x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[++ q.rear] = x;
    return true;
}

bool DeQueue(Queue &q, TreeNode *&x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[++ q.front];
    return true;
}

int cntNodeTwice(Tree &tree)
{
    Queue q;
    InitQueue(q);
    int cnt = 0;
    TreeNode *p;
    EnQueue(q, tree.root);
    while (!IsEmpty(q))
    {
        DeQueue(q, p);
        if (p->leftson && p->rightson)
            ++ cnt;
        if (p->leftson)
            EnQueue(q, p->leftson);
        if (p->rightson)
            EnQueue(q, p->rightson);
    }
    return cnt;
}
```

#### p09

```c++
/*
 * p08
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Queue
{
    int front, rear;
    TreeNode* data[MaxSize];
};
struct Tree
{
    TreeNode *root;
};
void InitQueue(Queue &q);
bool IsEmpty(Queue &q);
bool EnQueue(Queue &q, TreeNode *x);
bool DeQueue(Queue &q, TreeNode *&x);

void Init(Tree &tree);
TreeNode* CreateTree();
void sequence(TreeNode* r);
void ChangeLeft_Right(TreeNode *r);

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout << "交换前：";
    sequence(tree.root);
    ChangeLeft_Right(tree.root);
    puts("");
    cout << "交换后：";
    sequence(tree.root);
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}


void InitQueue(Queue &q)
{
    q.front = q.rear = -1;
}

bool IsEmpty(Queue &q)
{
    return q.front == q.rear;
}

bool EnQueue(Queue &q, TreeNode *x)
{
    if (q.rear == MaxSize)
        return false;
    q.data[++ q.rear] = x;
    return true;
}

bool DeQueue(Queue &q, TreeNode *&x)
{
    if (IsEmpty(q))
        return false;
    x = q.data[++ q.front];
    return true;
}

void sequence(TreeNode* r)
{
    Queue q;
    InitQueue(q);
    EnQueue(q, r);
    while (!IsEmpty(q))
    {
        TreeNode* tmp;
        DeQueue(q, tmp);
        cout << tmp->element << " ";
        if (tmp->leftson)
            EnQueue(q, tmp->leftson);
        if (tmp->rightson)
            EnQueue(q, tmp->rightson);
    }
}

void ChangeLeft_Right(TreeNode *r)
{
    if (! r)
        return ;
    ChangeLeft_Right(r->leftson);
    ChangeLeft_Right(r->rightson);

    TreeNode *tmp = r->leftson;
    r->leftson = r->rightson;
    r->rightson = tmp;
}
```

#### p10

```c++
/*
 * p10
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
};

void Init(Tree &tree);
TreeNode* CreateTree();
int Find_k(TreeNode *&r);
void Porder(TreeNode* r);
int k, id = 1;

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    puts("请输入需要获取先序遍历中第几个节点的值");
    cin >> k;
    if (k == -1)
    {
        puts("树中节点不足");
        return 0;
    }
    cout << "值为：" << Find_k(tree.root) << endl;
    cout << "先序：";
    Porder(tree.root);
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}


void Porder(TreeNode* r)
{
    if (!r)
        return ;
    cout << r->element << " ";
    Porder(r->leftson);
    Porder(r->rightson);
}
int Find_k(TreeNode *&r)
{
    if (!r)
        return -1;
    if (id == k)
        return r->element;
    ++ id;
    int val = Find_k(r->leftson);
    if (val != -1)
        return val;
    val = Find_k(r->rightson);
    return val;
}

```

#### p11

```c++
/*
 * p11
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
};

void Init(Tree &tree);
TreeNode* CreateTree();
void Porder(TreeNode* r);
void Del_x(TreeNode *&r, int x);


int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout <<"需删除的值：";
    int x;
    cin >> x;
    Porder(tree.root);
    puts("");
    Del_x(tree.root, x);
    Porder(tree.root);
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}

void Porder(TreeNode* r)
{
    if (!r)
        return ;
    cout << r->element << " ";
    Porder(r->leftson);
    Porder(r->rightson);
}

void Del_x(TreeNode *&r, int x)
{
    if (!r)
        return ;
    if (r->element == x)
    {
        delete r;
        r = NULL;
        return ;
    }
    Del_x(r->leftson, x);
    Del_x(r->rightson, x);
}
```

#### p12

```c++
/*
 * p12
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
};

struct Stack
{
    int top;
    TreeNode* data[MaxSize];
};

void InitStack(Stack &s);
bool IsEmpty(Stack &s);
bool Push(Stack &s, TreeNode* x);
bool Pop(Stack &s, TreeNode *&x);
bool GetTop(Stack &s, TreeNode *&x);


void Init(Tree &tree);
TreeNode* CreateTree();
void Find_ancestor(TreeNode *&r, int x);
Stack s;

int main()
{
    InitStack(s);
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    cout <<"寻找祖先的的值：";
    int x;
    cin >> x;
    Find_ancestor(tree.root, x);
    return 0;
}


void InitStack(Stack &s)
{
    s.top = -1;
}

bool IsEmpty(Stack &s)
{
    return s.top == -1;
}

bool Push(Stack &s, TreeNode *x)
{
    if (s.top == MaxSize - 1)
        return false;
    s.data[++ s.top] = x;
    return true;
}

bool Pop(Stack &s, TreeNode *&x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top --];
    return true;
}

bool GetTop(Stack &s, TreeNode *&x)
{
    if (IsEmpty(s))
        return false;
    x = s.data[s.top];
    return true;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}

void Find_ancestor(TreeNode *&r, int x)
{
    if (! r)
        return;
    if (r->element == x)
    {
        while (! IsEmpty(s))
        {
            TreeNode *tmp;
            Pop(s, tmp);
            cout << tmp->element << " ";
        }
    }
    Push(s, r);
    if (! r->leftson && ! r->rightson)
    {
        TreeNode *t;
        Pop(s, t);
        return ;
    }
    Find_ancestor(r->leftson, x);
    Find_ancestor(r->rightson, x);
}
```

#### p13

```c++
/*
 * p13
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef char ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
};
struct Tree
{
    TreeNode *root;
    bool tag;
};
void Init(Tree &tree);
void BuildTree(TreeNode *&r);
TreeNode* Ancestor(TreeNode *&r, TreeNode *&p, TreeNode *&q);

int main()
{
    Tree tree;
    Init(tree);
    BuildTree(tree.root);
    TreeNode *p = tree.root -> leftson ->rightson;
    TreeNode *q = tree.root -> rightson -> leftson;
    TreeNode *lca = Ancestor(tree.root, p, q);
    cout << lca->element << endl;
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

void BuildTree(TreeNode *&r)
{
    char ch;
    ch = getchar();
    if (ch == '#')
        r = NULL;
    else
    {
        r = new TreeNode;
        r->element = ch;
        r->leftson = NULL  ;
        r->rightson = NULL;
        BuildTree(r->leftson);
        BuildTree(r->rightson);
    }
}
// ABD##E##CF##G##
TreeNode* Ancestor(TreeNode *&r, TreeNode *&p, TreeNode *&q)
{
    Tree s1[110], s2[110];
    int top1 = 0, top2 = 0;
    TreeNode *bt = r;
    while (bt || top1 > 0)
    {
        while (bt)
        {
            s1[++ top1].root = bt;
            s1[top1].tag = 0;
            bt = bt->leftson;
        }
        while (top1 > 0 && s1[top1].tag == 1)
        {
            if (s1[top1].root == p)
            {
                for (int i = 1; i <= top1; ++ i)
                {
                    s2[i] = s1[i];
                    top2 = top1;
                }
            }
            if (s1[top1].root == q)
            {
                for (int i = top1; i > 0; -- i)
                    for (int j = top2; j > 0; -- j)
                        if (s1[i].root == s2[j].root)
                            return s1[i].root;
            }
             -- top1;
        }
        if (top1 != 0)
        {
            s1[top1].tag = 1;
            bt = s1[top1].root->rightson;
        }
    }
    return NULL;
}

```

#### p14

```c++
/*
 * p14
 */

#include <iostream>

using namespace std;
const int MaxSize = 110;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
    int deep;
};
struct Tree
{
    TreeNode *root;
};
int level[110];
void Init(Tree &tree);
TreeNode* CreateTree();
int sequence(TreeNode* r);

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    tree.root->deep = 1;
    int maxwidth = sequence(tree.root);
    cout << maxwidth << endl;
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}

int sequence(TreeNode* r)
{
    TreeNode* Queue[110];
    int front = -1, rear = -1;
    Queue[++ rear] = r;
    while (front < rear)
    {
        TreeNode *p = Queue[++ front];
        ++ level[p->deep];
        if (p->leftson)
        {
            p->leftson->deep = p->deep + 1;
            Queue[++ rear] = p->leftson;
        }
        if (p->rightson)
        {
            p->rightson->deep = p->deep + 1;
            Queue[++ rear] = p->rightson;
        }
    }
    int maxWidth = 0;
    for (int i = 0; i < 110; ++ i)
        if (level[i] > maxWidth)
            maxWidth = level[i];
    return maxWidth;
}
```

#### p15

```c++
/*
 * p15
 */

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int MasSize = 110;
void pre_to_post(char pre[], int l1, int r1, char post[], int l2, int r2);
char pre[MasSize], post[MasSize];

int main()
{
    cin.getline(pre, '\n');
    int len = strlen(pre);
    cout << len << endl;
    pre_to_post(pre, 0, len - 1, post, 0, len - 1);
    cout << "先序：" << pre << endl;
    cout << "后序：" << post << endl;
    return 0;
}

void pre_to_post(char pre[], int l1, int r1, char post[], int l2, int r2)
{
    int mid;
    if (r1 >= l1)
    {
        post[r2] = pre[l1];
        mid = (r1 - l1) / 2;
        pre_to_post(pre, l1 + 1, l1 + mid, post, l2, l2 + mid - 1);
        pre_to_post(pre, l1 + mid + 1, r1, post, l2 + mid, r2 - 1);
    }
}
```

#### p16

```c++
/*
 * p16
 */

#include <iostream>

using namespace std;
typedef int ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
    int deep;
};
struct Tree
{
    TreeNode *root;
};

void Init(Tree &tree);
TreeNode* CreateTree();
void leaf(TreeNode *& r);
TreeNode *pre, *head;

int main()
{
    Tree tree;
    puts("请输入根节点");
    tree.root = CreateTree();
    leaf(tree.root);
    while (head)
    {
        cout << head->element << " ";
        head = head->rightson;
    }
    return 0;
}

void Init(Tree &tree)
{
    tree.root = nullptr;
}

TreeNode* CreateTree()
{
    TreeNode *root = new TreeNode;
    int e;
    cin >> e;
    if (e == -1)
        return NULL;
    else
    {
        root->element = e;
        cout << "请输入左子树" << endl;
        root->leftson = CreateTree();
        cout << "请输入右子树" << endl;
        root->rightson = CreateTree();
        return root;
    }
}
void leaf(TreeNode *& r)
{
    if (r)
    {
        leaf (r->leftson);
        if (! r->leftson && ! r->rightson)
        {
            if (!pre)
            {
                head = r;
                pre = r;
            }
            else
            {
                pre->rightson = r;
                pre = r;
            }
        }
        leaf(r->rightson);
        pre->rightson = NULL;
    }
}
```

#### p17

```c++
/*
 * p17
 */

#include <iostream>

using namespace std;
typedef char ElemType;
struct TreeNode
{
    ElemType element;
    TreeNode *leftson, *rightson;
    int deep;
};
struct Tree
{
    TreeNode *root;
};

void BuildTree(TreeNode *&r);
bool IsSimilar(TreeNode *&r1, TreeNode *&r2);

int main()
{
    Tree tree1, tree2;
    tree1.root = tree2.root = NULL;
    cout << "first tree:";
    BuildTree(tree1.root);
    cout << "second tree:";
    BuildTree(tree2.root);
    if (IsSimilar(tree1.root, tree2.root))
        puts("YES");
    else
        puts("No");
    return 0;
}

void BuildTree(TreeNode *&r)
{
    char ch;
    cin >> ch;
    if (ch == '#')
    {
        r = NULL;
        return;
    }
    else
    {
        r = new TreeNode;
        r->element = ch;
        r->leftson = NULL;
        r->rightson = NULL;
        BuildTree(r->leftson);
        BuildTree(r->rightson);
    }
}

bool IsSimilar(TreeNode *&r1, TreeNode *&r2)
{
    bool left, right;
    if (!r1 && ! r2)
        return true;
    else if (! r1 || ! r2)
        return false;
    else
    {
        left = IsSimilar(r1->leftson, r2->leftson);
        right = IsSimilar(r1->rightson, r2->rightson);
        return left && right;
    }
}
```

#### p18

```c++
#include <iostream>
using namespace std;
typedef char ElemType;
struct TBNode
{
    ElemType data;
    int ltag, rtag;
    TBNode *lchild, *rchild;
};
struct TBTree
{
    TBNode *root;
};
// 建树
void BuildTree(TBNode *&r);
// 线索化
void InThread(TBNode *&r, TBNode *& pre);
// 封装将树线索化
void CreateeInTread(TBNode *&r);
//  求中序遍历二叉树中最后一个节点
TBNode* LastNode(TBNode *r);
// 求中序遍历二叉树中节点p得前驱
TBNode* FrontNode(TBNode *p);
void inorder(TBNode* r);

int main()
{
    TBTree tree;
    BuildTree(tree.root);
    cout << "中序遍历：";
    inorder(tree.root);
    puts("");
    CreateeInTread(tree.root);
    cout << "根节点得前驱：" << FrontNode(tree.root)->data << endl;

    return 0;
}

void BuildTree(TBNode *&r)
{
    ElemType ch;
    ch = getchar();
    if (ch == '#')
    {
        r = NULL;
        return ;
    }
    else
    {
        r = new TBNode;
        r->data = ch;
        r->ltag = r->rtag = 0;
        r->lchild = NULL;
        r->rchild = NULL;
        BuildTree(r->lchild);
        BuildTree(r->rchild);
    }
}

void InThread(TBNode *&r, TBNode *& pre)
{
    if (r)
    {
        InThread(r->lchild, pre);
        if (! r->lchild)
        {
            r->lchild = pre;
            r->ltag = 1;
        }
        if (pre && ! pre->rchild)
        {
            pre->rchild = r;
            pre->rtag = 1;
        }
        pre = r;
        InThread(r->rchild, pre);
    }
}

void CreateeInTread(TBNode *&r)
{
    TBNode *pre = NULL;
    if (r)
    {
        InThread(r, pre);
        pre->rchild = NULL;
        pre->rtag = 1;
    }
}

TBNode* LastNode(TBNode *r)
{
    while (r->rtag == 0)
        r = r->rchild;
    return r;
}

TBNode* FrontNode(TBNode *p)
{
    if (! p->ltag)
        return LastNode(p->lchild);
    else
        return p->lchild;
}

void inorder(TBNode* r)
{
    if (!r)
        return ;
    inorder(r->lchild);
    cout << r->data << " ";
    inorder(r->rchild);
}
```

#### p19

```c++
#include <iostream>
using namespace std;
typedef char ElemType;
const int MaxSize = 110;
struct TNode
{
    ElemType data;
    int weight;
    TNode *lchild, *rchild;
};
struct Tree
{
    TNode *root;
};
void BuildTree(TNode *&r);
int WPL(TNode *&r, int deep);
int WPL_Sequence(TNode *&r);

int main()
{
    Tree tree;
    BuildTree(tree.root);
    cout << "带权路径长度为(先序)：" << WPL(tree.root, 0) << endl;
    cout << "带权路径长度为(层序)：" << WPL_Sequence(tree.root) << endl;
    return 0;
}

void BuildTree(TNode *&r)
{
    ElemType  ch;
    cin >> ch;
    if (ch == '#')
    {
        r = NULL;
        return ;
    }
    else
    {
        r = new TNode;
        r->data = ch;
        r->weight = ch - '0';
        r->lchild = r->rchild = NULL;
        BuildTree(r->lchild);
        BuildTree(r->rchild);
    }
}

int WPL(TNode *&r, int deep)
{
    int wpl = 0;
    if (! r->lchild && ! r->rchild)
        wpl += deep * r->weight;
    if (r->lchild)
        wpl += WPL(r->lchild, deep + 1);
    if (r->rchild)
        wpl += WPL(r->rchild, deep + 1);
    return wpl;
}

int WPL_Sequence(TNode *&r)
{
    TNode* q[MaxSize];
    int hh = 0, tt = 0;
    int wpl = 0, deep = 0;
    TNode* lastNode;
    lastNode = r;
    TNode *nextLevelLastNode = NULL;
    q[tt ++] = r;
    while (hh < tt)
    {
        TNode* t = q[hh ++];
        if (! t->lchild && ! t->rchild)
            wpl += deep * t->weight;
        if (t->lchild)
        {
            q[tt ++] = t->lchild;
            nextLevelLastNode = t->lchild;
        }
        if (t->rchild)
        {
            q[tt ++] = t->rchild;
            nextLevelLastNode = t->rchild;
        }
        if (t == lastNode)
        {
            lastNode = nextLevelLastNode;
            ++ deep;
        }
    }
    return wpl;
}
```

#### p20

```c++
#include <iostream>
using namespace std;
struct TNode
{
    char data;
    TNode *lchild, *rchild;
};
struct Tree
{
    TNode *root;
};
void BuildTree(TNode *&r);
void Tran_to_exp(TNode *&r, int deep);

int main()
{
    Tree tree;
    BuildTree(tree.root);
    cout << "对应中缀表达式为： ";
    Tran_to_exp(tree.root, 1);
    return 0;
}


void BuildTree(TNode *&r)
{
    char ch;
    cin >> ch;
    if (ch == '#')
    {
        r = NULL;
        return ;
    }
    else
    {
        r = new TNode;
        r->data = ch;
        r->lchild = r->rchild = NULL;
        BuildTree(r->lchild);
        BuildTree(r->rchild);
    }
}

void Tran_to_exp(TNode *&r, int deep)
{
    if (! r)
        return ;
    else if (! r->lchild && ! r->rchild)
        cout << r->data;
    else
    {
        if (deep > 1)
            cout << "(";
        Tran_to_exp(r->lchild, deep + 1);
        cout << r->data;
        Tran_to_exp(r->rchild, deep + 1);
        if (deep > 1)
            cout << ')';
    }
}

```

#### p21

```c++
#include <iostream>
using namespace std;
const int MaxSize = 110;

struct SqBiTree
{
    int sqBiTNode[MaxSize];
    int ElemNum;
};

bool isBST(SqBiTree tree);
int a[10] = {40, 25, 60, -1, 30, -1,  80, -1, -1, 27};
int b[11] = {40, 50, 60, -1, 30, -1, -1, -1, -1, -1, 35};

int main()
{
    SqBiTree t1, t2;
    for (int i = 0; i < 10; ++ i)
        t1.sqBiTNode[i] = a[i];
    for (int i = 0; i < 11; ++ i)
        t2.sqBiTNode[i] = b[i];
    t1.ElemNum = 10;
    t2.ElemNum = 11;
    cout << "tree1: ";
    if (isBST(t1))
        puts("YES");
    else
        puts("NO");
    cout << "tree2: ";
    if (isBST(t2))
        puts("YES");
    else
        puts("NO");


    return 0;
}

bool isBST(SqBiTree tree)
{
    int *pmin, *pmax;
    pmin = new int[tree.ElemNum];
    pmax = new int[tree.ElemNum];
    for (int i = 0; i < tree.ElemNum; ++ i)
        pmin[i] = pmax[i] = tree.sqBiTNode[i];
    for (int i = tree.ElemNum - 1; i > 0; -- i)
    {
        if (tree.sqBiTNode[i] != -1)
        {
            int m = (i - 1) / 2;
            if (i % 2 == 1 && tree.sqBiTNode[m] > pmax[i])
                pmin[m] = pmin[i];
            else if (i % 2 == 0 && tree.sqBiTNode[m] < pmin[i])
                pmax[m] = pmax[i];
            else
                return false;
        }
    }
    return true;
}
```

### 5.4.4

#### p04

```c++
#include <iostream>
using namespace std;
typedef char ElemType;

struct CSNode
{
    ElemType data;
    CSNode *firstchild, *nextsibling;
};
struct CSTree
{
    CSNode *root;
};

void BuildTree(CSNode *&r);
// ABD#E##C##FG###
int leaves(CSNode *&r);

int main()
{
    CSTree tree;
    BuildTree(tree.root);
    cout << "leaves:  " << leaves(tree.root) << endl;
    return 0;
}

void BuildTree(CSNode *&r)
{
    ElemType ch;
    ch = getchar();
    if (ch == '#')
    {
        r = NULL;
        return ;
    }
    else
    {
        r = new CSNode;
        r->data = ch;
        r->firstchild = r->nextsibling = NULL;
        BuildTree(r->firstchild);
        BuildTree(r->nextsibling);
    }
}

int leaves(CSNode *&r)
{
    if (! r)
        return 0;
    if (! r->firstchild)
        return 1 + leaves(r->nextsibling);
    else if (r->firstchild)
        return leaves(r->firstchild) + leaves(r->nextsibling);
}
```

#### p05

```c++
/*
 * 05
 */
#include <iostream>
using namespace std;
typedef char ElemType;

struct CSNode
{
    ElemType data;
    CSNode *firstchild, *nextsibling;
};
struct CSTree
{
    CSNode *root;
};

void BuildTree(CSNode *&r);
// ABD#E##C##FG###
int Height(CSNode *&r);

int main()
{
    CSTree tree;
    BuildTree(tree.root);
    cout << "height: " << Height(tree.root) << endl;
    return 0;
}

void BuildTree(CSNode *&r)
{
    ElemType ch;
    ch = getchar();
    if (ch == '#')
    {
        r = NULL;
        return ;
    }
    else
    {
        r = new CSNode;
        r->data = ch;
        r->firstchild = r->nextsibling = NULL;
        BuildTree(r->firstchild);
        BuildTree(r->nextsibling);
    }
}

int Height(CSNode *&r)
{
    if (! r)
        return 0;
    else
    {
        int ltree = Height(r->firstchild);
        int rtree = Height(r->nextsibling);
        if (ltree + 1 > rtree)
            return ltree + 1;
        else
            return rtree;
    }
}
```

#### p06

```c++
/*
 * p06
 */
#include <iostream>
typedef char ElemType;
const int MaxSize = 110;
struct CSNode
{
    ElemType data;
    CSNode *firstchild, *nextsibling;
};

struct CSTree
{
    CSNode *root;
};
void createCSTree(CSNode *& r, ElemType e[], int degree[], int n);
void disp(CSNode *r);
ElemType e[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
int degree[] = {3, 2, 1, 0, 0, 0, 0};

int main()
{
    CSTree tree;
    createCSTree(tree.root, e, degree, 7);
    disp(tree.root);
    return 0;
}

void createCSTree(CSNode *& r, ElemType e[], int degree[], int n)
{
    CSNode **pointer = new CSNode*[MaxSize];
    for (int i = 0; i < n; ++ i)
    {
        pointer[i] = new CSNode;
        pointer[i]->data = e[i];
        pointer[i]->firstchild = pointer[i]->nextsibling = NULL;
    }
    int k = 0;

    for (int i = 0; i < n; ++ i)
    {
        int d = degree[i];
        if (d)
        {
            ++ k;
            pointer[i]->firstchild = pointer[k];
            for (int j = 2; j <= d; ++ j)
            {
                ++ k;
                pointer[k-1]->nextsibling = pointer[k];
            }
        }
    }
    r = pointer[0];

    delete []pointer;
}

void disp(CSNode *r)
{
    if (! r)
        return ;
    std::cout << r->data << " ";
    disp(r->firstchild);
    disp(r->nextsibling);
}
```

### 6.2.6

#### p04

```c++
/*
 * p04
 */
#include <iostream>
typedef char VertexType;
typedef int EdgeType;
const int MaxVertexNum = 110;
const int M = 110, N = 110;
struct ArcNode
{
    int adjvex; //弧所指向节点
    ArcNode *ne; //下一条弧
};

struct VNode
{
    VertexType data; // 顶点信息
    ArcNode *first;
};

struct ALGraph
{
    VNode vertices[MaxVertexNum];
    int vexnum, arcnum;
};

void convet(ALGraph &g, int mg[M][N]);

int main()
{

    return 0;
}


void convet(ALGraph &g, int mg[M][N])
{
    for (int i = 0; i < g.vexnum; ++ i)
    {
        ArcNode *p = g.vertices[i].first;
        while (p)
        {
            mg[i][p->adjvex] = 1;
            p = p->ne;
        }
    }
}
```

#### p06

```c++
#include <iostream>
const int MaxV = 110;

struct MGraph
{
    int numV, numE;
    char VList[MaxV];
    int edge[MaxV][MaxV];
};
bool IsExist(MGraph g);

int main()
{
    MGraph g;
    g.numV = 5;
    for (int i = 0; i < 5; ++ i)
        for (int j = 0; j < 5; ++ j)
            std::cin >> g.edge[i][j];
    std::cout << IsExist(g) << std::endl;
    return 0;
}

bool IsExist(MGraph g)
{
    int num = 0;
    for (int i = 0; i < g.numV; ++ i)
    {
        int degree = 0;
        for (int j = 0; j < g.numV; ++ j)
            degree += g.edge[i][j];
        if (degree % 2)
            ++ num;
    }
    return num == 0 || num == 2;
}
```

### 6.3.4

#### p02

```c++
#include <iostream>
#include <cstring>
typedef int ElemType;
const int N = 110;
struct Enode
{
    int adjVEx;
    ElemType w;
    Enode *nextArc;
};

struct LGraph
{
    int n;
    int e;
    Enode **a;
};
bool Init(LGraph *g, int nsize);
void Destory(LGraph *g);
bool Insert(LGraph *g, int u, int v, ElemType w);
bool Exist(LGraph *g, int u, int v);
bool Remove(LGraph *g, int u, int v);
void DFS(LGraph *g, int v, int &vnum, int &ednum, bool visited[]);
bool IsTree(LGraph *g);

int main()
{
    LGraph g;
    Init(&g, 6);
    Insert(&g, 1, 2, 0);
    Insert(&g, 1, 3, 0);
    Insert(&g, 2, 4, 0);
    Insert(&g, 2, 5, 0);
    Insert(&g, 4, 6, 0);
    Insert(&g, 6, 4, 0);
    Insert(&g, 4, 2, 0);
    Insert(&g, 5, 2, 0);
    Insert(&g, 3, 1, 0);
    Insert(&g, 2, 1, 0);
    if(IsTree(&g))
        puts("YES");
    else
        puts("NO");
    return 0;
}

bool Init(LGraph *g, int nsize)
{
    g->n = nsize;
    g->e = 0;
    g->a = (Enode**)malloc(nsize * sizeof(Enode*));
    if (!g->a)
        return false;
    else
    {
        for (int i = 1; i <= g->n; ++ i)
            g->a[i] = NULL;
        return true;
    }
}

void Destory(LGraph *g)
{
    for (int i = 1; i <= g->n; ++ i)
    {
        delete g->a[i];
        g->a[i] = NULL;
    }
    delete []g->a;
}

bool Exist(LGraph *g, int u, int v)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    p = g->a[u];
    while (p && p->adjVEx != v)
        p = p->nextArc;
    if (!p)
        return false;
    return true;
}


bool Insert(LGraph *g, int u, int v, ElemType w)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    if (Exist(g, u, v))
        return false;
    p = new Enode;
    p->adjVEx = v;
    p->w = w;
    p->nextArc = g->a[u];
    g->a[u] = p;
    ++ g->e;
    return true;
}

bool Remove(LGraph *g, int u, int v)
{
    Enode *p, *q;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    p = g->a[u];
    q = NULL;
    while (p && p->adjVEx != v)
    {
        q = p;
        p = p->nextArc;
    }
    if (! p)
        return false;
    if (q)
        q->nextArc = p->nextArc;
    else
        g->a[u] = p->nextArc;
    free(p);
    -- g->e;
    return true;
}

void DFS(LGraph *g, int v, int &vnum, int &ednum, bool visited[])
{
    Enode *w;
    visited[v] = true;
    std::cout << v << " ";
    ++ vnum;
    for (w = g->a[v]; w; w = w->nextArc)
        if (! visited[w->adjVEx])
            DFS(g, w->adjVEx, vnum, ++ ednum, visited);
}

bool IsTree(LGraph *g)
{
    bool *visited = new bool[g->n + 1];
//    memset(visited, false, sizeof visited);
    for (int i = 1; i <= g->n; ++ i)
        visited[i] = false;
    int vnum = 0, ednum = 0;
    DFS(g, 1, vnum, ednum, visited);
    puts("");
//    std::cout << "DFS: " << vnum << " " << ednum << std::endl;
    if (vnum == g->n && ednum == (g->n - 1))
        return true;
    else
        return false;
}


```

#### p03

```c++
#include <iostream>
#include <cstring>
typedef int ElemType;
const int N = 110;
struct Enode
{
    int adjVEx;
    ElemType w;
    Enode *nextArc;
};

struct LGraph
{
    int n;
    int e;
    Enode **a;
};
bool Init(LGraph *g, int nsize);
bool Insert(LGraph *g, int u, int v, ElemType w);
bool Exist(LGraph *g, int u, int v);
bool Remove(LGraph *g, int u, int v);
void DFS(LGraph g, int v, bool visited[]);
void DFSGraph(LGraph g);


int main()
{
    LGraph g;
    Init(&g, 6);
    Insert(&g, 1, 2, 0);
    Insert(&g, 1, 3, 0);
    Insert(&g, 2, 4, 0);
    Insert(&g, 2, 5, 0);
    Insert(&g, 4, 6, 0);
    Insert(&g, 6, 4, 0);
    Insert(&g, 4, 2, 0);
    Insert(&g, 5, 2, 0);
    Insert(&g, 3, 1, 0);
    Insert(&g, 2, 1, 0);
    DFSGraph(g);
    return 0;
}

bool Init(LGraph *g, int nsize)
{
    g->n = nsize;
    g->e = 0;
    g->a = (Enode**)malloc(nsize * sizeof(Enode*));
    if (!g->a)
        return false;
    else
    {
        for (int i = 1; i <= g->n; ++ i)
            g->a[i] = NULL;
        return true;
    }
}

bool Exist(LGraph *g, int u, int v)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    p = g->a[u];
    while (p && p->adjVEx != v)
        p = p->nextArc;
    if (!p)
        return false;
    return true;
}


bool Insert(LGraph *g, int u, int v, ElemType w)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    if (Exist(g, u, v))
        return false;
    p = new Enode;
    p->adjVEx = v;
    p->w = w;
    p->nextArc = g->a[u];
    g->a[u] = p;
    ++ g->e;
    return true;
}

bool Remove(LGraph *g, int u, int v)
{
    Enode *p, *q;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    p = g->a[u];
    q = NULL;
    while (p && p->adjVEx != v)
    {
        q = p;
        p = p->nextArc;
    }
    if (! p)
        return false;
    if (q)
        q->nextArc = p->nextArc;
    else
        g->a[u] = p->nextArc;
    free(p);
    -- g->e;
    return true;
}

void DFS(LGraph g, int v, bool visited[])
{
    Enode *w;
    visited[v] = true;
    int *Stack = new int[g.n + 1];
    int top = -1;
    Stack[++ top] = v;
    visited[v] = true;
    while (top != -1)
    {
        int k = Stack[top --];
        std::cout << k << " ";
        for (w = g.a[k]; w; w = w->nextArc)
            if (! visited[w->adjVEx])
            {
                Stack[++top] = w->adjVEx;
                visited[w->adjVEx] = true;
            }
    }
}

void DFSGraph(LGraph g)
{
    bool *visited = new bool[g.n + 1];
//    memset(visited, 0, sizeof  visited);
    for (int i = 1; i <= g.n; ++ i)
        visited[i] = false;
    for (int i = 1; i <= g.n; ++ i)
        if (!visited[i])
            DFS(g, i, visited);
    delete []visited;
}
```

#### p04

```c++
#include <iostream>
#include <cstring>
typedef int ElemType;
const int N = 110;
struct Enode
{
    int adjVEx;
    ElemType w;
    Enode *nextArc;
};

struct LGraph
{
    int n;
    int e;
    Enode **a;
};
bool Init(LGraph *g, int nsize);
bool Insert(LGraph *g, int u, int v, ElemType w);
bool Exist(LGraph *g, int u, int v);
void DFS(LGraph g, int v, bool visited[]);
bool DFSGraph(LGraph g, int u, int v);
void BFS(LGraph g, int v, bool visited[]);
bool BFSGraph(LGraph g, int u, int v);


int main()
{
    LGraph g;
    Init(&g, 6);
    Insert(&g, 1, 2, 0);
    Insert(&g, 1, 3, 0);
    Insert(&g, 2, 4, 0);
    Insert(&g, 2, 5, 0);
    Insert(&g, 4, 6, 0);
    Insert(&g, 6, 4, 0);
    Insert(&g, 4, 2, 0);
    Insert(&g, 5, 2, 0);
    Insert(&g, 3, 1, 0);
    Insert(&g, 2, 1, 0);
    if (DFSGraph(g, 1, 4))
        puts("DFS:  YES");
    else
        puts("DFS:  NO");
    if (BFSGraph(g, 1, 4))
        puts("BFS:  YES");
    else
        puts("BFS:  NO");
    return 0;
}

bool Init(LGraph *g, int nsize)
{
    g->n = nsize;
    g->e = 0;
    g->a = (Enode**)malloc(nsize * sizeof(Enode*));
    if (!g->a)
        return false;
    else
    {
        for (int i = 1; i <= g->n; ++ i)
            g->a[i] = NULL;
        return true;
    }
}

bool Exist(LGraph *g, int u, int v)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    p = g->a[u];
    while (p && p->adjVEx != v)
        p = p->nextArc;
    if (!p)
        return false;
    return true;
}


bool Insert(LGraph *g, int u, int v, ElemType w)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    if (Exist(g, u, v))
        return false;
    p = new Enode;
    p->adjVEx = v;
    p->w = w;
    p->nextArc = g->a[u];
    g->a[u] = p;
    ++ g->e;
    return true;
}

void DFS(LGraph g, int v, bool visited[])
{
    Enode *w;
    std::cout << v << " ";
    visited[v] = true;
    for (w = g.a[v]; w; w = w->nextArc)
        if (! visited[w->adjVEx])
            DFS(g, w->adjVEx, visited);
}

bool DFSGraph(LGraph g, int u, int v)
{
    bool *visited = new bool[g.n + 1];
//    memset(visited, 0, sizeof  visited);
    for (int i = 1; i <= g.n; ++ i)
        visited[i] = false;
    DFS(g, u, visited);
    return visited[v];
}

void BFS(LGraph g, int v, bool visited[])
{
    Enode *w;
    int *q = new int[g.n + 1];
    int hh = 0, tt = -1;
    q[++ tt] = v;
    visited[v] = true;
    while(hh <= tt)
    {
        int t = q[hh ++];
        std::cout << t << " ";
        for (w = g.a[t]; w; w = w->nextArc)
        {
            if (! visited[w->adjVEx])
            {
                visited[w->adjVEx] = true;
                q[++ tt] = w->adjVEx;
            }
        }
    }
}

bool BFSGraph(LGraph g, int u, int v)
{
    bool *visited = new bool[g.n + 1];
    for (int i = 1; i <= g.n; ++ i)
        visited[i] = false;
    BFS(g, u, visited);
    return visited[v];
}
```

#### p05

```c++
#include <iostream>
#include <cstring>
typedef int ElemType;
const int N = 110;
struct Enode
{
    int adjVEx;
    ElemType w;
    Enode *nextArc;
};

struct LGraph
{
    int n;
    int e;
    Enode **a;
};
int Stack[N];
bool visited[N];
int top = 0;
bool Init(LGraph *g, int nsize);
bool Insert(LGraph *g, int u, int v, ElemType w);
bool Exist(LGraph *g, int u, int v);
void BFS(LGraph g, int v, bool visited[]);
bool BFSGraph(LGraph g, int u, int v);
void DFS(LGraph g, int u, int v);

int main()
{
    LGraph g;
    Init(&g, 6);
    Insert(&g, 1, 2, 0);
    Insert(&g, 2, 1, 0);
    Insert(&g, 2, 3, 0);
    Insert(&g, 3, 2, 0);
    Insert(&g, 1, 6, 0);
    Insert(&g, 6, 1, 0);
    Insert(&g, 6, 2, 0);
    Insert(&g, 2, 6, 0);
    Insert(&g, 5, 6, 0);
    Insert(&g, 6, 5, 0);
    Insert(&g, 3, 5, 0);
    Insert(&g, 5, 3, 0);
    Insert(&g, 7, 5, 0);
    Insert(&g, 5, 7, 0);
    DFS(g, 1, 5);
    return 0;
}

bool Init(LGraph *g, int nsize)
{
    g->n = nsize;
    g->e = 0;
    g->a = (Enode**)malloc(nsize * sizeof(Enode*));
    if (!g->a)
        return false;
    else
    {
        for (int i = 1; i <= g->n; ++ i)
            g->a[i] = NULL;
        return true;
    }
}

bool Exist(LGraph *g, int u, int v)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    p = g->a[u];
    while (p && p->adjVEx != v)
        p = p->nextArc;
    if (!p)
        return false;
    return true;
}


bool Insert(LGraph *g, int u, int v, ElemType w)
{
    Enode *p;
    if (u < 1 || v < 1 || u > g->n || v > g->n || u == v)
        return false;
    if (Exist(g, u, v))
        return false;
    p = new Enode;
    p->adjVEx = v;
    p->w = w;
    p->nextArc = g->a[u];
    g->a[u] = p;
    ++ g->e;
    return true;
}

void DFS(LGraph g, int u, int v)
{
    if (u == v && !visited[u])
    {
        for (int i = 1; i <= top; ++ i)
            std::cout << Stack[i] << " ";
        std::cout << v << " ";
        puts("");
        return ;
    }
    visited[u] = true;
    Stack[ ++ top] = u;
    for (Enode *w = g.a[u]; w; w = w->nextArc)
    {
        if (! visited[w->adjVEx])
            DFS(g, w->adjVEx, v);
    }
    visited[u] = false;
    -- top;
}

```

